{
  "hash": "ae9817cdc068f32a41f3012fd210114f",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Problem Set 3\nnumber-sections: true\nengine: julia\n---\n\n## Minimum and Maximum Variance Analysis\n\n> Minimize the variance $Ïƒ^2$ Eq. (8.4) of Ch. 8 by writing out the derivatives with respect to the vector components. Show that the solution is given by Equation (8.7) which is an eigenvalue problem with orthogonal eigenvectors.\n\n$$\n\\sigma^2=\\frac{1}{M} \\sum_{m=1}^M\\left|\\left(\\boldsymbol{B}^{(m)}-\\langle\\boldsymbol{B}\\rangle\\right) \\cdot \\hat{\\boldsymbol{n}}\\right|^2\n$$ {#eq-Chen84}\n\n$$\n\\sum_{\\nu=1}^3 M_{\\mu \\nu}^B n_\\nu=\\lambda n_\\mu\n$$ {#eq-Chen87}\n\n\nExpand the dot product in components:\n\n$$\n\\left(\\boldsymbol{B}^{(m)} - \\langle \\boldsymbol{B} \\rangle\\right) \\cdot \\hat{\\boldsymbol{n}} = \\sum_{\\mu=1}^3 \\left(B_\\mu^{(m)} - \\langle B_\\mu \\rangle\\right) n_\\mu,\n$$\n\nso that\n\n$$\n\\sigma^2 = \\frac{1}{M} \\sum_{m=1}^M \\left(\\sum_{\\mu=1}^3 \\left(B_\\mu^{(m)} - \\langle B_\\mu \\rangle\\right) n_\\mu \\right)^2 = \\sum_{\\mu,\\nu=1}^3 n_\\mu n_\\nu \\left[ \\frac{1}{M} \\sum_{m=1}^M \\left(B_\\mu^{(m)} - \\langle B_\\mu \\rangle\\right) \\left(B_\\nu^{(m)} - \\langle B_\\nu \\rangle\\right) \\right]\n$$\n\n\nDefine the magnetic variance matrix\n\n$$\nM_{\\mu\\nu}^B \\equiv \\left\\langle B_\\mu B_\\nu \\right\\rangle - \\langle B_\\mu \\rangle \\langle B_\\nu \\rangle\n$$\n\nso that\n\n$$\n\\sigma^2 = \\sum_{\\mu,\\nu=1}^3 n_\\mu M_{\\mu\\nu}^B n_\\nu.\n$$\n\n\nThe Lagrangian is given by:\n\n$$\nL(\\hat{\\boldsymbol{n}}, \\lambda) = \\sigma^2 - \\lambda\\left(\\sum_{\\mu=1}^3 n_\\mu^2 - 1\\right) = \\sum_{\\mu,\\nu=1}^3 n_\\mu M_{\\mu\\nu}^B n_\\nu - \\lambda\\left(\\sum_{\\mu=1}^3 n_\\mu^2 - 1\\right).\n$$\n\nDifferentiate with Respect to the Components $n_\\alpha$ equal to zero for each component\n\n$$\n\\frac{\\partial}{\\partial n_\\alpha} \\left(\\sum_{\\mu,\\nu} n_\\mu M_{\\mu\\nu}^B n_\\nu\\right) - \\frac{\\partial}{\\partial n_\\alpha} \\left[\\lambda\\left(\\sum_{\\mu=1}^3 n_\\mu^2 - 1\\right)\\right] = 2\\sum_{\\nu=1}^3 M_{\\alpha\\nu}^B n_\\nu -  2\\lambda n_\\alpha.\n$$\n\nwe get:\n\n$$\n2\\sum_{\\nu=1}^3 M_{\\alpha\\nu}^B n_\\nu - 2\\lambda n_\\alpha = 0.\n$$\n\nThis is exactly Equation (8.7): $\\sum_{\\nu=1}^3 M_{\\mu \\nu}^B n_\\nu = \\lambda n_\\mu$. The equation is an eigenvalue problem for the symmetric $3\\times 3$ matrix $M_{\\mu\\nu}^B$. The eigenvalues $\\lambda$ are real, and the corresponding eigenvectors $\\hat{\\boldsymbol{n}}$ are orthogonal.\n\n\n<!-- \nThe minimum variance technique is designed to deal with the situation where some or all of the non-ideal effects mentioned above, except a systematic temporal change in the normal direction, $\\hat{\\boldsymbol{n}}$, are present. As the estimate of $\\hat{\\boldsymbol{n}}$, the method identifies that direction in space along which the field-component set $\\left\\{\\boldsymbol{B}^{(m)} \\cdot \\hat{\\boldsymbol{n}}\\right\\}(m=1,2,3 \\ldots M)$ has minimum variance. In other words, $\\hat{\\boldsymbol{n}}$ is determined by minimisation of\n\n$$\n\\sigma^2=\\frac{1}{M} \\sum_{m=1}^M\\left|\\left(\\boldsymbol{B}^{(m)}-\\langle\\boldsymbol{B}\\rangle\\right) \\cdot \\hat{\\boldsymbol{n}}\\right|^2\n$$\n\nwhere the average $\\langle\\boldsymbol{B}\\rangle$ is defined by\n\n$$\n\\langle\\boldsymbol{B}\\rangle \\equiv \\frac{1}{M} \\sum_{m=1}^M \\boldsymbol{B}^{(m)}\n$$\n\nand where the minimisation is subject to the normalisation constraint $|\\hat{n}|^2=1$. Using a Lagrange multiplier, $\\lambda$, to implement this constraint, one then seeks the solution of the set of three homogeneous linear equations\n\n$$\n\\begin{aligned}\n\\frac{\\partial}{\\partial n_X}\\left(\\sigma^2-\\lambda\\left(|\\hat{\\boldsymbol{n}}|^2-1\\right)\\right) & =0 \\\\\n\\frac{\\partial}{\\partial n_Y}\\left(\\sigma^2-\\lambda\\left(|\\hat{\\boldsymbol{n}}|^2-1\\right)\\right) & =0 \\\\\n\\frac{\\partial}{\\partial n_Z}\\left(\\sigma^2-\\lambda\\left(|\\hat{\\boldsymbol{n}}|^2-1\\right)\\right) & =0\n\\end{aligned}\n$$\n\nwhere $\\sigma^2$ is given by equation 8.4 and $\\hat{\\boldsymbol{n}}$ is represented in terms of its three components ( $n_X, n_Y, n_Z$ ) along the cartesian coordinate system $X, Y, Z$ (e.g., GSE or GSM) in which the field data $\\left\\{\\boldsymbol{B}^{(m)}\\right\\}$ are given. When the differentiations in equation 8.6 have been performed, the resulting set of three equations can be written in matrix form as\n\n$$\n\\sum_{\\nu=1}^3 M_{\\mu \\nu}^B n_\\nu=\\lambda n_\\mu\n$$\n\nwhere the subscripts $\\mu, v=1,2,3$ denote cartesian components along the $X, Y, Z$ system and\n\n$$\nM_{\\mu \\nu}^B \\equiv\\left\\langle B_\\mu B_\\nu\\right\\rangle-\\left\\langle B_\\mu\\right\\rangle\\left\\langle B_v\\right\\rangle\n$$\n\nis the magnetic variance matrix. It is seen from equation 8.7 that the allowed $\\lambda$ values are the eigenvalues $\\lambda_1, \\lambda_2, \\lambda_3$ (given here in order of decreasing magnitude) of $M_{\\mu \\nu}^B$. Since $M_{\\mu \\nu}^B$ is symmetric, the eigenvalues are all real and the corresponding eigenvectors, $\\boldsymbol{x}_1$, $\\boldsymbol{x}_2$, and $\\boldsymbol{x}_3$, are orthogonal.\n-->\n\n## Electromagnetic ion cyclotron waves\n\n> Electromagnetic ion cyclotron waves are left-hand polarized waves excited by velocity space anisotropy (perpendicular gradients in velocity distribution function). They are typically below the ion cyclotron frequency for each species (H+, He+ or O+). MMS observations on 2015 Dec. 14, show that such waves were excited after the passage of a shock.\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Speasy\nspz = speasy()\n\nusing Dates\nusing DimensionalData\nusing CairoMakie\nusing SpaceTools\nusing Unitful\nusing DSP\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/DimensionalData/M9vEC/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/dev/Speasy/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/PythonCall/WMWY0/CondaPkg.toml\n    CondaPkg Dependencies already up to date\n```\n:::\n:::\n\n\n\n### Spectrogram with cyclotron frequencies\n\n> [a] Obtain MMS 1 (or 2,3,4) data between 13:27 and 13:29 UT, from the FGM instrument in GSM coordinates, and plot the spectrogram of the X or Y component between 0-2Hz. Overlay the 3 cyclotron frequencies, as shown in Fig. 5 of the paper (for subset of time). [Note: you should create a low-pass filtered version of the average field at 5-10s window to compute the cyclotron frequencies with; for that use tsmooth2 (IDL) or pyspedas.interpol (PySPEDAS) after degap/clip/deflaging the data first].\n\nhttps://cdaweb.gsfc.nasa.gov/misc/NotesM.html#MMS1_FGM_SRVY_L2\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nt0 = \"2015-12-14T13:10:00\"\nt1 = \"2015-12-14T13:50:00\"\ntvars = \"cda/MMS1_FGM_SRVY_L2/mms1_fgm_b_gsm_srvy_l2_clean\"\nda = get_data(tvars, t0, t1) |> DimArray\nda = SpaceTools.modify_meta(da, long_name=\"B\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get MMS1_FGM_SRVY_L2/mms1_fgm_b_gsm_srvy_l2_clean without web service, switching to web service\n/Users/zijin/projects/beforerr/.CondaPkg/env/lib/python3.11/site-packages/speasy/core/data_containers.py:18: UserWarning: no explicit representation of timezones available for np.datetime64\n  return np.searchsorted(time, np.datetime64(key, 'ns'), side='left')\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nâ”Œ 19199Ã—4 DimArray{Unitful.Quantity{Float32, ğŒ ğˆâ»Â¹ ğ“â»Â², Unitful.FreeUnits{(nT,), ğŒ ğˆâ»Â¹ ğ“â»Â², nothing}}, 2} mms1_fgm_b_gsm_srvy_l2_clean â”\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ dims â”¤\n  â†“ Ti                           Sampled{Dates.DateTime} [2015-12-14T13:10:00, â€¦, 2015-12-14T13:49:59.783] ForwardOrdered Irregular Points,\n  â†’ mms1_fgm_b_gsm_srvy_l2_clean Categorical{Symbol} [Symbol(\"Bx GSM\"), Symbol(\"By GSM\"), Symbol(\"Bz GSM\"), :Bt] Unordered\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ metadata â”¤\n  Dict{Any, Any} with 19 entries:\n  \"REPRESENTATION_1\"  => \"represent_vec_tot\"\n  \"SCALETYP\"          => \"linear\"\n  \"FILLVAL\"           => Any[-1.0e31]\n  \"DEPEND_0\"          => \"Epoch\"\n  \"FIELDNAM\"          => \"Magnetic field vector in GSM plus Btotal (8 or 16 S/sâ€¦\n  \"VALIDMAX\"          => Any[17000.0, 17000.0, 17000.0, 17000.0]\n  \"SI_CONVERSION\"     => \"1.0e-9>T\"\n  \"LABL_PTR_1\"        => Any[\"Bx GSM\", \"By GSM\", \"Bz GSM\", \"Bt    \"]\n  \"TENSOR_ORDER\"      => Any[1]\n  \"axes\"              => VariableAxis[Speasy.VariableAxis:â€¦\n  \"COORDINATE_SYSTEM\" => \"GSM\"\n  \"FORMAT\"            => \"E13.5\"\n  \"VAR_TYPE\"          => \"data\"\n  \"CATDESC\"           => \"Magnetic field vector in Geocentric Solar Magnetospheâ€¦\n  :long_name          => \"B\"\n  \"DISPLAY_TYPE\"      => \"time_series\"\n  \"VALIDMIN\"          => Any[-17000.0, -17000.0, -17000.0, 0.0]\n  \"DIM_SIZES\"         => Any[4]\n  \"UNITS\"             => \"nT\"\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n â‹®      â‹±  \n```\n:::\n:::\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nusing SignalAnalysis\nusing PlasmaFormulary\n\np = SpaceTools.pspectrum(da[:, 1])\nbegin\n    f = tplot(p; colorrange=(1e-7, 1), alpha=0.7)\n    ax = current_axis()\n    ylims!(ax, 0u\"Hz\", 2u\"Hz\")\n\n    B_ts = smooth(da, 5u\"s\")[:, 4]\n\n    ic_H = gyrofrequency.(B_ts, :\"H+\") .|> Ï‰2f\n    ic_He = gyrofrequency.(B_ts, :\"He+\") .|> Ï‰2f\n    ic_He2 = gyrofrequency.(B_ts, :\"He2+\") .|> Ï‰2f\n    ic_O = gyrofrequency.(B_ts, :\"O+\") .|> Ï‰2f\n    tplot_panel!.(current_axis(), [ic_H, ic_He, ic_He2, ic_O])\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.007986138746711634)\nâ”” @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:21\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.007986138746711634)\nâ”” @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:21\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-4-output-2.svg){}\n:::\n:::\n\n\n\n### Band-pass filtered data\n\n> [b] Plot the GSM time series of the band-pass filtered data between 0.2 â€“ 2 Hz (again using tsmooth2/pyspedas.interpol to first low-pass filter the data at 0.2Hz, subtract it from the original to create the high-pass residual >0.2Hz, then low-pass filter that with a 2Hz window).\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\ntime = DateTime(\"2015-12-14T13:20:00\") .. DateTime(\"2015-12-14T13:30:00\")\nsda = da[time, 1:3]\n# Band-pass filter the data between 0.2-2 Hz\n# First step: Low-pass filter at 0.2 Hz\nlp_02Hz = smooth(sda, 5u\"s\")  # 0.2 Hz â‰ˆ 5 second window\n# High-pass by subtracting low-pass from original\nhp_02Hz = amap(-, sda, lp_02Hz)\n# Second step: Low-pass filter at 2 Hz (0.5 second window)\nbp_filtered = smooth(hp_02Hz, 0.5u\"s\")\n\ntplot([lp_02Hz, hp_02Hz, bp_filtered])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.007984877076234697)\nâ”” @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:21\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.007984753171800809)\nâ”” @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:21\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-5-output-2.svg){}\n:::\n:::\n\n\n\nActually, the frequency response of an $M$ point moving average filter is not a perfect low-pass filter.\n\n$$\nH[f]=\\frac{\\sin (\\pi f M)}{M \\sin (\\pi f)}\n$$\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nbp_filtered2 = filtfilt(sda, 0.2u\"Hz\", 2u\"Hz\").data\ntplot([hp_02Hz, bp_filtered, bp_filtered2])\ncurrent_figure()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.007984877076234697)\nâ”” @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:21\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-6-output-2.svg){}\n:::\n:::\n\n\n\n\n### Minimum Variance Analysis\n\n> [c] Use minvar_matrix_make (IDL or pyspedas) applied on the band-pass filtered data to obtain the minimum variance matrix, on a sliding window. You can control the width and shift of the window (see keywords). Rotate the data in i,j,k (max,int,min) coordâ€™s using tvector_rotate (in IDL / Py - SPEDAS; see how to use it from class examples, or from cribs / readthedocs). Plot the data in that coordinate system.\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\ntime = DateTime(\"2015-12-14T13:20:00\") .. DateTime(\"2015-12-14T13:30:00\")\nB_ts = bp_filtered[time, 1:3]\nB_mva_ts = mva(B_ts, B_ts)\n\nB_ts_2 = bp_filtered2[time, 1:3]\nB_mva_ts_2 = mva(B_ts_2, B_ts_2)\n\ntplot([B_ts, B_mva_ts, B_ts_2, B_mva_ts_2])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n\n### Minvar direction\n\n> [d] The code minvar_matrix_make allows you to output the eigenvectors and eigenvalues. Plot the eigenvalues and evaluate the confidence in the minvar direction. Plot the angle between the minvar direction and the direction of the ambient magnetic field (the 5-10s average above).\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nusing LinearAlgebra\nusing Statistics\nusing SpaceTools\nusing Dates\n\n# Load magnetic field data around the shock crossing\nt0 = DateTime(\"2008-09-05T15:30:00\")\nt1 = DateTime(\"2008-09-05T15:40:00\")\nb_data = get_data(\"cda/THA_L2_FGM/tha_fgs_gse\", t0, t1) |> DimArray\nB = b_data.data  # Get the magnetic field components\n\n# Get eigenvalues and eigenvectors\nF = mva_mat(B)\n\n# The minimum variance direction (shock normal)\nnÌ‚ = F.vectors[:, 3]  # Third eigenvector corresponds to minimum variance\n\n# Calculate Î¸Bn (angle between B-field and shock normal)\nB_avg = mean(B, dims=1)[1, :]\nB_avg_norm = B_avg / norm(B_avg)\nÎ¸Bn = acosd(abs(dot(B_avg_norm, nÌ‚)))\n\n# Calculate Bn (shock-normal magnetic field component)\nBn = dot(B_avg, nÌ‚)\n\nprintln(\"Results of Minimum Variance Analysis:\")\nprintln(\"Shock normal (GSE coordinates): \", round.(nÌ‚, digits=3))\nprintln(\"Î¸Bn: \", round(Î¸Bn, digits=1), \"Â°\")\nprintln(\"Bn: \", Bn)\ncheck_mva_mat(F; verbose=true)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit nT*GSE*(All*Qs)\nResults of Minimum Variance Analysis:\nShock normal (GSE coordinates): Float32[-0.215, -0.966, 0.143]\nÎ¸Bn: 61.5Â°\nBn: 26.65665\nFloat32[0.0060435473 0.97663194 -0.21483368; 0.14459603 -0.21343324 -0.9661977; 0.9894723 0.025224842 0.14250703]\nRatio of intermediate variance to minimum variance = 1.8064607\nâ”Œ Warning: Take the MVA result with a grain of salt!\nâ”” @ SpaceTools ~/.julia/dev/SpaceTools/src/cotrans/mva.jl:82\n```\n:::\n:::\n\n\n\n### Hodogram\n\n> [e] There are several bursts of EMIC wave power in the interval. Pick one clean burst with 5-10 cycles and plot the B-field hodogram in the plane of polarization (max,int). (Bandpass filtering first will help). Is it left-hand polarized as expected? [Note that the minvar code ensures a right-hand orthogonal system, but you may have to switch vectors around if the angle to B-field is not less than 90deg].\n\n<!-- Figure 7. Three-axis plot of MMS 1 magnetic field data rotated into local field-aligned coordinates and band-pass filtered from 0.4 to 2.0 Hz, with uniform scale, from 1327:15 to 1328:15 UT on 14 December 2015. -->\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\ninterval = DateTime(\"2015-12-14T13:40:20\") .. DateTime(\"2015-12-14T13:40:40\")\nlet\n    sda = da[interval, 1:3]\n    bp_filtered = filtfilt(sda, 0.8u\"Hz\", 2u\"Hz\").data\n    B_mva_ts = mva(bp_filtered, bp_filtered)\n    f = Figure(; size=(1200, 800))\n    Bx = B_mva_ts[:, [1]]\n    By = B_mva_ts[:, [2]]\n    Bz = B_mva_ts[:, [3]]\n    tplot(f[1, 1], [sda, bp_filtered, B_mva_ts])\n    tplot(f[1, 2], [Bx, By, Bz]; link_yaxes=true)\n    time = dims(Bx, 1).val\n    color = (time .- time[1]) ./ (time[end] - time[1])\n    lines(f[1, 3], Bx[:, 1].data, By[:, 1].data, color=color)\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.007949285570537276)\nâ”” @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:21\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-9-output-2.svg){}\n:::\n:::\n\n\n\nHodogram analysis indicated left handed polarization during the interval.\n\n## Shock crossings\n\n> Shock crossings were observed by ARTEMIS P1 (TH-B) in the solar wind on 2013-07-09 20:40UT and on 2014-06-09 16:58UT, both captured in Fast Survey and published in Fig. 3 (analysis results in Table 1 of Zhou et al., 202022). Pick one of the two to study.\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nusing LinearAlgebra\nusing Statistics\nusing DataFrames, TimeSeries\n```\n:::\n\n\n\n### Shock normal\n\n> [a] Determine, using minimum variance analysis, the shock normal, the angle between the B-field and the shock normal, and the shock-normal magnetic field component, Bn.\n\nThe shock angle, $Î¸_{Bn}$, the angle between the directions of the upstream magnetic field and the shock normal;\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\n# Load magnetic field data around the shock crossing\nt0 = DateTime(\"2013-07-09T20:37:00\")  # Start a few minutes before the crossing\nt1 = DateTime(\"2013-07-09T20:45:00\")  # End a few minutes after\nb_data = get_data(\"cda/THB_L2_FGM/thb_fgs_gse\", t0, t1) |> DimArray\ntplot(b_data; add_title=true)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit nT*GSE*(All*Qs)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-11-output-2.svg){}\n:::\n:::\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\n# Perform MVA analysis using the built-in function\nF = mva_mat(b_data)\n\n# The minimum variance direction (shock normal)\nnÌ‚ = F.vectors[:, 3]  # Third eigenvector corresponds to minimum variance\n\n# Calculate Î¸Bn (angle between B-field and shock normal)\nB_up = vec(mean(b_data[1:10, :].data; dims=1))\nÎ¸Bn = angle(B_up, nÌ‚)\n\n# Calculate Bn (shock-normal magnetic field component)\nBn = dot(B_up, nÌ‚)\n\nprintln(\"Results of Minimum Variance Analysis for ARTEMIS P1 shock crossing (2013-07-09):\")\nprintln(\"Shock normal (GSE coordinates): \", round.(nÌ‚, digits=3))\nprintln(\"Î¸_Bn: \", round(Î¸Bn, digits=1), \"Â°\")\nprintln(\"Bn: \", Bn)\ncheck_mva_mat(F, verbose=true)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResults of Minimum Variance Analysis for ARTEMIS P1 shock crossing (2013-07-09):\nShock normal (GSE coordinates): Float32[0.923, 0.347, 0.164]\nÎ¸_Bn: 75.4Â°\nBn: 2.5922403\nFloat32[-0.27282175 0.2701564 0.9233546; 0.29161265 -0.8913902 0.3469665; 0.91680443 0.36392197 0.16440956]\nRatio of intermediate variance to minimum variance = 10.369079\n[ Info: Seems to be a proper MVA attempt!\n```\n:::\n:::\n\n\n\n### Minimum variance direction\n\n> [b] Note that there are significant waves downstream but not upstream, which is common for weak (subcritical) shocks. Starting from a small interval barely encompassing the shock (<1min in length), increase the interval by ~0.5 min and recalculate. Then increase again and recalculate. Do so for ~10-20 times until you reach ~10min encompassing the shock. The solution will initially fluctuate from one to the next choice of intervals, then stabilize, then start being jittery again because you are including the waves. Plot the minimum variance direction (two angles, elevation and azimuth, in GSE) and Bn, all as a function of the interval chosen. Pick and report the best solution, based on the shortest time interval choice when the solution becomes stable.\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\nazimuth(x) = rad2deg(atan(x[2], x[1]))\nelevation(x) = rad2deg(asin(x[3]))\n\n# Central time of the shock crossing for ARTEMIS P1 (2013-07-09)\nt_start = DateTime(\"2013-07-09T20:39:00\")\ntime_shock = DateTime(\"2013-07-09T20:39:30\")\n\nn = 20\nt_ends = [time_shock + Second(30 * (i - 1)) for i in 1:n]\nb_data = get_data(\"cda/THB_L2_FGM/thb_fgs_gse\", t_start, t_ends[end]) |> DimArray\nb_data.metadata[:units] = \"nT\"\n\nnÌ‚s = map(t_ends) do t_end\n    b_data_subset = b_data[t_start..t_end, :]\n    F = mva_mat(b_data_subset)\n    F.vectors[:, 3]\nend\n\nBn = dot.(Ref(B_up), nÌ‚s)\ndirection = DimArray(\n    [azimuth.(nÌ‚s) elevation.(nÌ‚s)],\n    (Ti(t_ends), Y([:azimuth, :elevation]));\n    name=:direction\n)\nBns = DimArray(Bn, Ti(t_ends); name=:Bn)\nÎ”Bn = abs.(diff(Bns))\nÎ”Bn = SpaceTools.rename(Î”Bn, :Î”Bn)\n\ntvars = [b_data, direction, [Bns, Î”Bn]]\nf, axes = tplot(tvars; add_title=true)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit nT*GSE*(All*Qs)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-13-output-2.svg){}\n:::\n:::\n\n\n\nThe solution becomes stable around \"2013-07-09T20:43:00\", about 4 mins after the shock crossing. after \"2013-07-09T20:45:00\" the solution becomes jittery because the waves are included.\n\n### Error estimates\n\n> [c] The noise in Bn and the minimum variance directions (angular noise) are tabulated in equations 8.24 and 8.23 of Chapter 8. Plot the $Î”B_n$ and $Î”Ï†$ separately. Check if they support your choice of interval.\n\nThe angular error estimates (in radians) is \n\n$$\n\\begin{aligned}\n\\left|\\Delta \\varphi_{i j}\\right|=\\left|\\Delta \\varphi_{j i}\\right| & =\\left\\langle\\left\\langle\\left(\\Delta x_{i j}\\right)^2\\right\\rangle\\right\\rangle^{1 / 2}=\\left\\langle\\left\\langle\\left(\\Delta x_{j i}\\right)^2\\right\\rangle\\right\\rangle^{1 / 2} \\\\\n& =\\sqrt{\\frac{\\lambda_3}{(M-1)} \\frac{\\left(\\lambda_i+\\lambda_j-\\lambda_3\\right)}{\\left(\\lambda_i-\\lambda_j\\right)^2}}, \\quad i \\neq j\n\\end{aligned}\n$$\n\nThe composite statistical error estimate for $\\left\\langle\\mathbf{B} \\cdot \\mathbf{x}_3\\right\\rangle$ is\n\n$$\n\\left|\\Delta\\left\\langle\\mathbf{B} \\cdot \\mathbf{xâ‚ƒ}\\right\\rangle\\right|=\\sqrt{\\frac{\\lambda_3}{M-1}+\\left(\\Delta \\varphi_{32}\\langle\\mathbf{B}\\rangle \\cdot \\mathbf{x}_2\\right)^2+\\left(\\Delta \\varphi_{31}\\langle\\mathbf{B}\\rangle \\cdot \\mathbf{x}_1\\right)^2}\n$$\n\n\n```julia\n\"\"\"\n    Î”Ï†ij(Î»áµ¢, Î»â±¼, Î»â‚ƒ, M)\n\nCalculate the phase error between components i and j according to:\n|Î”Ï†áµ¢â±¼| = |Î”Ï†â±¼áµ¢| = âˆš(Î»â‚ƒ/(M-1) * (Î»áµ¢ + Î»â±¼ - Î»â‚ƒ)/(Î»áµ¢ - Î»â±¼)Â²)\n\nParameters:\n- Î»áµ¢: eigenvalue i\n- Î»â±¼: eigenvalue j\n- Î»â‚ƒ: smallest eigenvalue (Î»â‚ƒ)\n- M: number of samples\n\"\"\"\nfunction Î”Ï†ij(Î»áµ¢, Î»â±¼, Î»â‚ƒ, M)\n    return sqrt((Î»â‚ƒ / (M - 1)) * (Î»áµ¢ + Î»â±¼ - Î»â‚ƒ) / (Î»áµ¢ - Î»â±¼)^2)\nend\n\n\"\"\"\nCalculate the composite statistical error estimate for âŸ¨BÂ·xâ‚ƒâŸ©:\n|Î”âŸ¨BÂ·xâ‚ƒâŸ©| = âˆš(Î»â‚ƒ/(M-1) + (Î”Ï†â‚ƒâ‚‚âŸ¨BâŸ©Â·xâ‚‚)Â² + (Î”Ï†â‚ƒâ‚âŸ¨BâŸ©Â·xâ‚)Â²)\n\nParameters:\n- Î»â‚, Î»â‚‚, Î»â‚ƒ: eigenvalues in descending order\n- M: number of samples\n- B: mean magnetic field vector\n- xâ‚, xâ‚‚, xâ‚ƒ: eigenvectors\n\"\"\"\nfunction B_x3_error(Î»â‚, Î»â‚‚, Î»â‚ƒ, M, B, xâ‚, xâ‚‚, xâ‚ƒ)\n    Î”Ï†â‚ƒâ‚‚ = Î”Ï†ij(Î»â‚ƒ, Î»â‚‚, Î»â‚ƒ, M)\n    Î”Ï†â‚ƒâ‚ = Î”Ï†ij(Î»â‚ƒ, Î»â‚, Î»â‚ƒ, M)\n    B_xâ‚‚ = dot(B, xâ‚‚)\n    B_xâ‚ = dot(B, xâ‚)\n    return sqrt(Î»â‚ƒ / (M - 1) + (Î”Ï†â‚ƒâ‚‚ * B_xâ‚‚)^2 + (Î”Ï†â‚ƒâ‚ * B_xâ‚)^2)\nend\n\nB_x3_error(F::Eigen, M, B) = \n    B_x3_error(F.values..., M, B, eachcol(F.vectors)...)\n```\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\nres = map(t_ends) do t_end\n    b_data_subset = b_data[t_start..t_end, :]\n    F = mva_mat(b_data_subset)\n    M = size(b_data_subset, 1)\n    B = mean(b_data_subset.data; dims=1)\n\n    Î»â‚ = F.values[1]\n    Î»â‚‚ = F.values[2]\n    Î»â‚ƒ = F.values[3]\n    Î”Ï†12 = SpaceTools.Î”Ï†ij(Î»â‚, Î»â‚‚, Î»â‚ƒ, M)\n    Î”Ï†13 = SpaceTools.Î”Ï†ij(Î»â‚, Î»â‚ƒ, Î»â‚ƒ, M)\n    Î”Ï†23 = SpaceTools.Î”Ï†ij(Î»â‚‚, Î»â‚ƒ, Î»â‚ƒ, M)\n    B_x3_err = SpaceTools.B_x3_error(F, M, B)\n    (; time=t_end, Î”Ï†12, Î”Ï†13, Î”Ï†23, B_x3_err)\nend\n\nerrors = SpaceTools.nt2ds(res)\ntvars = [\n    b_data,\n    [errors.Î”Ï†12, errors.Î”Ï†13, errors.Î”Ï†23],\n    errors.B_x3_err,\n]\ntplot(tvars)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps3_files/figure-html/cell-14-output-1.svg){}\n:::\n:::\n\n\n\nThe error estimates support our choice of interval.\n\n",
    "supporting": [
      "ps3_files"
    ],
    "filters": [],
    "includes": {}
  }
}