{
  "hash": "1135e48d55a21b63c0912215704162cf",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Problem Set 5\nengine: julia\n---\n\n## A whistler mode chorus event\n\n> Obtain and analyze DC and AC wave data for an event, including wave polarization and Poynting flux. A whistler mode chorus event observed by THEMIS, occurred on TH-E (P5) at ~10:00-10:15 UT on 2008-12-15 (referenced in the class notes in Lecture 10, p.5) taken from the paper by Li et al., JGR 2011.\n\n> In the overview plots (here and here), E & B wavepower is significant during significant velocity oscillations. A different whistler mode chorus event was observed by MMS on 2019-08-16 at ~09:32:00UT within a flux pileup region shown in Fig. 2 of Fu et al., GRL 2025. MMS overview plot is here. Follow the structure of Hwk05_01.pro (just an example). Work in either IDL or PySPEDAS, for either the THEMIS or the MMS event to:\n\n> - Fig. 1. Identify the event in overview plots and point out the wave power related to it\n> - Fig. 2. Get the Electric Field (Double-Probe) Instruments (EFI) data, remove offsets, show ExB velocity, using E*B=0 approximation\n> - Fig. 3. Plot on-board computed spectra. Overplot fce, 1⁄2 fce\n> - Fig. 4. Recognize (wave)burst times in the waveforms and plot them and the spectra\n> - Fig. 5. Introduce E and B and show ground computed spectra (wavelet and Fourier)\n> - Fig. 6. Rotate into FAC coord’s and feed waveforms into wave analysis program. Plot results. Read the section of the relevant paper and explain the role/significance of the whistler waves in their respective setting.\n> - Fig. 7. Show the Poynting flux for the band-passed signal. Do this is time domain (process time series in real space) and in frequency domain (using the available tools).  \n> Deliver a report explaining what you did, and your code.\n\n### Identification in overview plots\n\n@liModulationWhistlerMode2011\n\n![[overview summary](https://themis.ssl.berkeley.edu/summary.php?year=2008&month=12&day=15&hour=1012&sumType=the&type=overview)](https://themis.ssl.berkeley.edu/themisdata/overplots/2008/12/15/the_l2_overview_20081215_1012.png)\n\nWe can clearly observe from the overview plot, specifically in the final panel, that the FBK exhibits wave activity within the frequency range of approximately 10–100 Hz. Additionally, it is evident that this wave activity is modulated with a period of roughly 10 seconds.\n\n![[moms summary](https://themis.ssl.berkeley.edu/summary.php?year=2008&month=12&day=15&hour=1012&sumType=the&type=moms)](https://themis.ssl.berkeley.edu/themisdata/overplots/2008/12/15/the_l2_moms_20081215_1012.png)\n\nSimilarly, the pressure, magnetic field, temperature, and electron density measurements also exhibit oscillations with a comparable period.\n\n### Electric field data\n\n> Get the Electric Field (Double-Probe) Instruments (EFI) data, remove offsets, show ExB velocity, using E*B=0 approximation\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Speasy\nusing CairoMakie\nusing GLMakie\nusing Dates\nusing SpaceTools\nusing SpaceTools: tplot\nusing LinearAlgebra\nusing Statistics\nusing DimensionalData\nusing Unitful\nusing PlasmaFormulary\nusing SignalAnalysis\nusing Speasy: get_data\nSpaceTools.DEFAULTS.add_title = true\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/DimensionalData/M9vEC/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/dev/Speasy/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/PythonCall/WMWY0/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/dev/PySPEDAS/CondaPkg.toml\n    CondaPkg Initialising pixi\n             │ /Users/zijin/.julia/artifacts/d2fecc2a9fa3eac2108d3e4d9d155e6ff5dfd0b2/bin/pixi\n             │ init\n             │ --format pixi\n             └ /Users/zijin/projects/beforerr/.CondaPkg\n✔ Created /Users/zijin/projects/beforerr/.CondaPkg/pixi.toml\n    CondaPkg Wrote /Users/zijin/projects/beforerr/.CondaPkg/pixi.toml\n             │ [dependencies]\n             │ netcdf4 = \"*\"\n             │ openssl = \">=3, <3.1\"\n             │ uv = \">=0.4\"\n             │ xarray = \"*\"\n             │ sqlite = \"!=3.49.1\"\n             │ numpy = \"*\"\n             │ \n             │     [dependencies.python]\n             │     channel = \"conda-forge\"\n             │     build = \"*cpython*\"\n             │     version = \">=3.8,<4\"\n             │ \n             │ [project]\n             │ name = \".CondaPkg\"\n             │ platforms = [\"osx-arm64\"]\n             │ channels = [\"conda-forge\"]\n             │ channel-priority = \"strict\"\n             │ description = \"automatically generated by CondaPkg.jl\"\n             │ \n             │ [pypi-dependencies.speasy]\n             │ git = \"https://github.com/SciQLop/speasy\"\n             │ \n             │ [pypi-dependencies.pyspedas]\n             └ git = \"https://github.com/spedas/pyspedas\"\n    CondaPkg Installing packages\n             │ /Users/zijin/.julia/artifacts/d2fecc2a9fa3eac2108d3e4d9d155e6ff5dfd0b2/bin/pixi\n             │ install\n             └ --manifest-path /Users/zijin/projects/beforerr/.CondaPkg/pixi.toml\n WARN Using local manifest /Users/zijin/projects/beforerr/.CondaPkg/pixi.toml rather than /Users/zijin/projects/beforerr/pyproject.toml from environment variable `PIXI_PROJECT_MANIFEST`\n✔ The default environment has been installed.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# Define time intervals for the analysis\ntrange_plus = TimeRange(\"2008-12-15T09:45:00\", \"2008-12-15T10:30:00\")\ntrange = TimeRange(\"2008-12-15T09:55:00\", \"2008-12-15T10:20:00\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTimeRange{String, Intervals.Closed, Intervals.Closed}(\"2008-12-15T09:55:00\", \"2008-12-15T10:20:00\")\n```\n:::\n:::\n\n\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\n\"\"\"\nReference: [SPEDAS](https://github.com/spedas/bleeding_edge/blob/master/projects/themis/spacecraft/fields/thm_load_fit.pro)\n\"\"\"\nfunction thm_load_fit(probe, timerange; vars=(\"fgs_dsl\", \"efs_dsl\", \"efs_0_dsl\", \"efs_dot0_dsl\"))\n    dataset = \"TH$(uppercase(probe))_L2_FIT\"\n    vars = \"th$(lowercase(probe))_\" .* vars\n    ids = \"cda/$dataset/\" .* vars\n    das = DimArray.(get_data(ids, timerange))\n    return NamedTuple{Tuple(Symbol.(vars))}(das)\nend\n\ndata = thm_load_fit(\"e\", trange)\n\ntplot(data)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-4-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\nHere's the Julia equivalent of the provided IDL code for removing offsets and calculating electric field components:\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\n# Get Ez (dsl) and ExB\nlet B = data.the_fgs_dsl, E = data.the_efs_dsl, angle = 20.0  # degrees\n    # First get Ex/y offsets\n    println(\"Select 2 times (Start/Stop) for obtaining Ex, Ey offsets\")\n    trange4offset = [\"2008-12-15T10:30:00\", \"2008-12-15T10:40:00\"]\n\n    data_offset = thm_load_fit(\"e\", trange4offset)\n    Eoffsets = tmean(data_offset.the_efs_dsl)\n    @info \"Eoffsets\" Eoffsets.data\n\n    # Set angle threshold\n    tanangle = tan(angle * π / 180.0)\n\n    # Calculate the condition for each data point\n    B = B[DimSelectors(E)]\n    bxy_magnitude = sqrt.(B[:, 1] .^ 2 + B[:, 2] .^ 2)\n    angle_condition = abs.(B[:, 3] ./ bxy_magnitude) .>= tanangle\n    igood = findall(angle_condition)\n    ibad = findall(.!angle_condition)\n    janygood = length(igood)\n    janybad = length(ibad)\n    @info \"janygood\" janygood\n    @info \"janybad\" janybad\n    # Apply offsets to Ex and Ey components\n    E_corrected = deepcopy(E)\n    E_corrected[:, 1] .-= Eoffsets[1]\n    E_corrected[:, 2] .-= Eoffsets[2]\n\n    # Set bad data points to NaN\n    if janybad >= 1\n        for i in ibad\n            E_corrected[i, :] .= NaN\n        end\n    end\n\n    if janygood < 1\n        println(\"*****WARNING: NO GOOD 3D ExB data\")\n    else\n        for i in igood\n            E_corrected[i, 3] =\n                -(E_corrected[i, 1] * B[i, 1] +\n                  E_corrected[i, 2] * B[i, 2]) /\n                B[i, 3]\n        end\n    end\n\n    f = Figure()\n    tplot(f[1, 1], data_offset)\n    tplot(f[1, 2:4], [B, E, E_corrected, data.the_efs_0_dsl, data.the_efs_dot0_dsl])\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSelect 2 times (Start/Stop) for obtaining Ex, Ey offsets\n┌ Info: Eoffsets\n│   Eoffsets.data =\n│    1×3 Matrix{Quantity{Float32, 𝐋 𝐌 𝐈⁻¹ 𝐓⁻³, Unitful.FreeUnits{(m⁻¹, mV), 𝐋 𝐌 𝐈⁻¹ 𝐓⁻³, nothing}}}:\n└     -0.90413 mV m⁻¹  0.0725118 mV m⁻¹  -25.9938 mV m⁻¹\n┌ Warning: (DimensionalData.Dimensions.Dim{:the_efs_dsl},) dims were not found in object.\n└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/M9vEC/src/Dimensions/primitives.jl:844\n┌ Info: janygood\n└   janygood = 489\n┌ Info: janybad\n└   janybad = 0\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-5-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\nIn the left panel, we present the data utilized for the offset analysis. In the right panel, arranged sequentially from top to bottom, we display the magnetic field data, the electric field data, the electric field data corrected using our offset analysis, and finally, the corresponding electric field data extracted from the L2 dataset `efs_0_dsl` and `efs_dot0_dsl`.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nlet E = data.the_efs_dot0_dsl, B = data.the_fgs_dsl\n    B_int = tinterp(B, E)\n    V = tcross(E, B_int) ./ tdot(B_int, B_int) .|> u\"km/s\"\n    V = modify_meta(V, long_name=\"Velocity\", labels=(\"Vx\", \"Vy\", \"Vz\"))\n    tplot([B, E, V])\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-6-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\nComputed $V= E × B/B^2$ is shown in the last panel.\n\n### On-board computed spectra\n\n> Plot on-board computed spectra. Overplot fce, 1⁄2 fce\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction thm_load_fbk(probe, timerange; vars=(\"fb_edc12\", \"fb_scm1\"))\n    dataset = \"TH$(uppercase(probe))_L2_FBK\"\n    vars = \"th$(lowercase(probe))_\" .* vars\n    ids = \"cda/$dataset/\" .* vars\n    DimArray.(get_data(ids, timerange))\nend\n\nthm_fb_edc12, thm_fb_scm1 = thm_load_fbk(\"e\", trange) .|> SpaceTools.set_colorrange\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit <|mV/m|>\n[ Info: Cannot parse unit <|nT|>\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{DimMatrix{Float32, D, Tuple{}, Matrix{Float32}, Symbol, Dict{Any, Any}} where D<:Tuple}:\n Float32[0.014709114 0.0073833982 … 0.012690215 0.01730484; 0.014709114 0.020304345 … 0.009229247 0.01730484; … ; 0.014709114 0.0 … 0.008075591 0.01730484; 0.0 0.0 … 0.013843872 0.020765807]\n Float32[0.0032959487 0.00077439536 … 0.003418021 0.0085832; 0.0032959487 0.00077439536 … 0.0028839551 0.009536888; … ; 0.0032959487 0.00082780194 … 0.0023498894 0.0014305334; 0.00343328 0.00082780194 … 0.0024567025 0.0071526663]\n```\n:::\n:::\n\n\n\nThe three lines in Figures represent 1 fce (blue), 0.5 fce (orange), and 0.1 fce (green).\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nlet B = tnorm(data.the_fgs_dsl)\n    fce = gyrofrequency.(B, :e) .|> ω2f\n    fce = modify_meta(fce, scale=log10) ./ 1u\"Hz\"\n    f = tplot([thm_fb_edc12, thm_fb_scm1]; add_title=true, alpha=0.7)\n    tplot_panel!.(f.axes, Ref([fce, fce / 2, fce / 10]))\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-8-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\n`ffw_16_eac34` and `ffp_16_eac34` `ffp_16_scm3` data are not available for this event.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction thm_load_fft(probe, timerange; vars=(\"ffw_16_eac34\", \"ffp_16_eac34\", \"ffp_16_scm3\"))\n    dataset = \"TH$(uppercase(probe))_L2_FFT\"\n    vars = \"th$(lowercase(probe))_\" .* vars\n    ids = \"cda/$dataset/\" .* vars\n    DimArray.(get_data(ids, timerange))\nend\n\nfft_tvars = [\n    \"cda/THE_L2_FFT/the_ffp_16_eac34\",\n    \"cda/THE_L2_FFT/the_ffp_16_scm3\",\n    \"cda/THE_L2_FFT/the_ffw_16_eac34\",\n    \"cda/THE_L2_FFT/the_ffw_16_scm3\",\n]\n\nfft_data = get_data.(fft_tvars, trange)\nall(ismissing.(fft_data)) && @warn \"Data not available\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNon compliant ISTP file: trying to load the_ffp_16_eac34_yaxis_vary as support data for the_ffp_16_eac34 but it is absent from the file\nNon compliant ISTP file: trying to load the_ffp_16_scm3_yaxis_vary as support data for the_ffp_16_scm3 but it is absent from the file\nNon compliant ISTP file: trying to load the_ffw_16_eac34_yaxis_vary as support data for the_ffw_16_eac34 but it is absent from the file\nNon compliant ISTP file: trying to load the_ffw_16_scm3_yaxis_vary as support data for the_ffw_16_scm3 but it is absent from the file\nNon compliant ISTP file: swapping DEPEND_0 with DEPEND_TIME for the_ffw_16_scm3, if you think this is a bug report it here: https://github.com/SciQLop/PyISTP/issues\n┌ Warning: Data not available\n└ @ Main.Notebook ~/projects/beforerr/docs/courses/epss261/homework/ps5.qmd:193\n```\n:::\n:::\n\n\n\n\n### Waveburst and spectra\n\n> Recognize (wave)burst times in the waveforms and plot them and the spectra.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntvars = [\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n    \"cda/THE_L2_SCM/the_scw_dsl\",\n]\n\nthm_scp_dsl, thm_scw_dsl = get_data.(tvars, trange_plus) .|> DimArray\nf = Figure()\ntplot(f[1, 1], [thm_scp_dsl, thm_scw_dsl])\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit nT*DSL\n[ Info: Cannot parse unit nT*DSL\n[ Info: Resampling array of size (228865, 3) along dimension 1 from 228865 to 6070 points\n[ Info: Resampling array of size (391173, 3) along dimension 1 from 391173 to 6070 points\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-10-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\nWe see a waveburst around 2008-12-15T10:13:10.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\ntvars_wb = [\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n    \"cda/THE_L2_SCM/the_scw_dsl\",\n    \"cda/THE_L2_FBK/the_fb_scm1\",\n]\ntrange_wb = TimeRange(\"2008-12-15T10:13:10\", \"2008-12-15T10:13:20\")\ntrange_wb_s = TimeRange(\"2008-12-15T10:13:10\", \"2008-12-15T10:13:17\")\ndata_wb = get_data.(tvars_wb, trange_wb) .|> DimArray\ntplot(f[1, 2], data_wb)\ntlims!(trange_wb_s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit nT*DSL\n[ Info: Cannot parse unit nT*DSL\n[ Info: Cannot parse unit <|nT|>\n[ Info: Resampling array of size (63403, 3) along dimension 1 from 63403 to 6070 points\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n┌ Warning: Automatically using edge for Makie because transform == log10 and the first edge is negative\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/methods.jl:40\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-11-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\n\n### Ground computed spectra\n\n> Introduce E and B and show ground computed spectra (wavelet and Fourier)\n\n```julia\nusing PySPEDAS.Projects\nthm_efi_ds = themis.efi(trange, level=\"l1\", probe=\"e\")\nthm_efw = DimArray(thm_efi_ds.the_efw)\n```\n\nLoading `efw` data using `PySPEDAS` is somehow quite slow, instead we define a configuration file and load the `efw` data from the SPDF.\n\n```{yaml}\nthe_efw_l1:\n  inventory_path: spdf/THEMIS/THE/L1/EFW\n  master_cdf: https://spdf.gsfc.nasa.gov/pub/data/themis/the/l1/efw/2021/the_l1_efw_20210102_v01.cdf\n  split_frequency: daily\n  split_rule: regular\n  url_pattern: https://spdf.gsfc.nasa.gov/pub/data/themis/the/l1/efw/{Y}/the_l1_efw_{Y}{M:02d}{D:02d}_v\\d+.cdf\n  use_file_list: true\n```\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nthe_efw_l1_index = speasy.inventories.data_tree.archive.spdf.THEMIS.THE.L1.EFW.the_efw_l1\ntvars = [\n    \"cda/THE_L2_FGM/the_fgs_gsm\",\n    \"cda/THE_L2_FGM/the_fgh_gsm\",\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n    \"cda/THE_L2_SCM/the_scw_dsl\"\n]\nthm_fgs_gsm, thm_fgh_gsm, thm_scp_dsl, thm_scw_dsl = get_data(tvars, trange_plus) .|> DimArray\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit nT*GSM*(All*Qs)\n[ Info: Cannot parse unit nT*GSM*(All*Qs)\n[ Info: Cannot parse unit nT*DSL\n[ Info: Cannot parse unit nT*DSL\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{DimMatrix{Float32, D, Tuple{}, Matrix{Float32}, Symbol, Dict{Any, Any}} where D<:Tuple}:\n Float32[-6.884452 2.770554 13.2441; -6.8816504 2.699388 13.368085; … ; -10.854679 -2.0566497 25.193708; -11.012929 -1.8605247 25.144516]\n Float32[-4.202244 1.5139444 15.179175; -4.1365685 1.664007 15.140432; … ; -8.527703 -0.975849 22.252335; -8.648017 -1.0026835 22.07751]\n Float32[-7.3053866f-6 -1.8908788f-5 -2.836187f-5; -7.3053866f-6 -1.8908788f-5 -2.836187f-5; … ; 4.3625614f-6 5.230054f-6 -9.406129f-6; 4.3625614f-6 5.230054f-6 -9.406129f-6]\n Float32[-0.000119733224 0.00037838318 -0.00024678188; -0.000119733224 0.00037838318 -0.00024678188; … ; 0.0017912713 -0.0006972916 0.0004022404; 0.0017912713 -0.0006972916 0.0004022404]\n```\n:::\n:::\n\n\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nthm_fgs_gsm_z_dpwrspc = SpaceTools.pspectrum(thm_fgs_gsm[:, 3]; nfft=64) |> SpaceTools.set_colorrange\nthm_scp_dsl_z_dpwrspc = SpaceTools.pspectrum(thm_scp_dsl[:, 3]; nfft=512) |> SpaceTools.set_colorrange\nthm_fgh_gsm_z_dpwrspc = SpaceTools.pspectrum(thm_fgh_gsm[:, 3]) |> SpaceTools.set_colorrange\n\ntvars_wb = [\n    the_efw_l1_index.the_efw,\n    \"cda/THE_L2_SCM/the_scw_dsl\"\n]\n\nthm_efw, thm_scw_dsl = get_data.(tvars_wb, trange_wb) .|> DimArray\n\nthm_scw_dsl_z_dpwrspc = SpaceTools.pspectrum(thm_scw_dsl[:, 3]) |> SpaceTools.set_colorrange\nthm_efw_z_dpwrspc = SpaceTools.pspectrum(thm_efw[:, 3]) |> SpaceTools.set_colorrange\n\nf = Figure()\ntplot(f[1, 1], [\n    thm_fgs_gsm, thm_fgs_gsm_z_dpwrspc,\n    thm_fgh_gsm, thm_fgh_gsm_z_dpwrspc,\n    thm_scp_dsl, thm_scp_dsl_z_dpwrspc,\n])\n\ntplot(f[1, 2], [\n    thm_scw_dsl, thm_scw_dsl_z_dpwrspc,\n    thm_efw, thm_efw_z_dpwrspc,\n])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 510.99292220984336)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 511.99292220984336)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n[ Info: Cannot parse unit \n[ Info: Cannot parse unit nT*DSL\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n[ Info: Resampling array of size (228864, 3) along dimension 1 from 228864 to 6070 points\n[ Info: Resampling array of size (228865, 3) along dimension 1 from 228865 to 6070 points\n[ Info: Resampling array of size (63403, 3) along dimension 1 from 63403 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-13-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\nDuring the interval when we have wavebursts, the whistle wave is clearly identifiable in the SCP data. However, in the higher-frequency data product, it becomes difficult to discern any distinct signatures within the spectrogram.\n\n### FAC coordinate\n\n> Rotate into FAC coord’s and feed waveforms into wave analysis program. Plot results. Read the section of the relevant paper and explain the role/significance of the whistler waves in their respective setting.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\ntvars = [\n    \"cda/THE_L2_FGM/the_fgs_dsl\",\n    \"cda/THE_L2_FGM/the_fgh_dsl\",\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n]\n_trange = [\"2008-12-15T09:59\", \"2008-12-15T10:13\"]\n\nthm_fgs_dsl, thm_fgh_dsl, thm_scp_dsl = Speasy.get_data(tvars, _trange) .|> DimArray\n\nfac_mats = tfac_mat(thm_fgs_dsl)\nthm_scp_fac = select_rotate(thm_scp_dsl, fac_mats, \"FAC\")\nthm_fgh_fac = select_rotate(thm_fgh_dsl, fac_mats, \"FAC\")\n\nf = Figure()\n\ntplot(f[1, 1], [\n    thm_fgs_dsl,\n    thm_fgh_dsl,\n    thm_scp_dsl,\n])\ntplot(f[1, 2], [\n    thm_fgh_fac,\n    thm_scp_fac,\n])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Cannot parse unit nT*DSL*(All*Qs)\n[ Info: Cannot parse unit nT*DSL*(All*Qs)\n[ Info: Cannot parse unit nT*DSL\n┌ Warning: (DimensionalData.Dimensions.Dim{:the_scp_dsl},) dims were not found in object.\n└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/M9vEC/src/Dimensions/primitives.jl:844\n┌ Warning: (DimensionalData.Dimensions.Dim{:the_fgh_dsl},) dims were not found in object.\n└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/M9vEC/src/Dimensions/primitives.jl:844\n[ Info: Resampling array of size (107008, 3) along dimension 1 from 107008 to 6070 points\n[ Info: Resampling array of size (107520, 3) along dimension 1 from 107520 to 6070 points\n[ Info: Resampling array of size (107008, 3) along dimension 1 from 107008 to 6070 points\n[ Info: Resampling array of size (107520, 3) along dimension 1 from 107520 to 6070 points\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-14-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\n#### Wave polarization analysis\n\n::: {.cell .column-page fig-width='15' execution_count=1}\n``` {.julia .cell-code}\nf = Figure(;)\ntplot(f[1, 1], thm_fgh_fac)\ntplot(f[2:6, 1], twavpol(thm_fgh_fac))\ntplot(f[1, 2], thm_scp_fac)\ntplot(f[2:6, 2], twavpol(thm_scp_fac))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ Info: Resampling array of size (107008, 3) along dimension 1 from 107008 to 6070 points\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 511.99292220984336)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n[ Info: Resampling array of size (107520, 3) along dimension 1 from 107520 to 6070 points\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-15-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\nCompressional pulsations are associated with modulations of resonant electron fluxes and chorus intensity.\n\nWe have developed a high-performance wave polarization program implemented in Julia, achieving a significant speedup of approximately 100 times compared to its Python counterpart. Furthermore, our implementation is more generalizable, extending the original program’s capabilities to accommodate data in n dimensions. The program is accessible via the following link:\n\n- https://beforerr.github.io/SpaceTools.jl/dev/explanations/waves/\n- https://beforerr.github.io/SpaceTools.jl/dev/validation/pyspedas/\n\nCore part is attached in the appendix.\n\n###  Poynting flux\n\n- [thm_crib_poynting_flux.pro](https://github.com/spedas/bleeding_edge/blob/master/projects/themis/examples/advanced/thm_crib_poynting_flux.pro)\n- [thm_efi_clean_efw.pro](https://github.com/spedas/bleeding_edge/blob/8714f1b9c390780619403f2c56c35f5be675b34b/projects/themis/spacecraft/fields/LASP/thm_efi_clean_efw.pro)\n\nFrom top to bottom, we present the original data, the cleaned data with spikes removed, and the filtered data.\n\nThe right panel provides a magnified view of the data presented in the left panel\n\nWe can see that removing spikes is essential for the accuracy of the filtered data.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nbegin\n    E = tclip(thm_efw, trange_wb) |> standardize\n    E_clean = replace_outliers(E; window=128)\n    E_sm = tfilter(E, 64u\"Hz\")\n    E_clean_sm = tfilter(tinterp_nans(E_clean), 64u\"Hz\")\n\n    tvars = [E, E_clean, E_sm, E_clean_sm] .|> timeshift\n    f = Figure()\n    tplot(f[1, 1], tvars)\n    fa2 = tplot(f[1, 2], tvars; link_yaxes=true)\n    tlims!.(fa2.axes, 3.44u\"s\", 3.48u\"s\")\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-16-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nPoynting_vector(E, B) = tcross(E, B) ./ Unitful.μ0\n\nbegin\n    B = tclip(thm_scw_dsl, trange_wb)\n    E = tclip(thm_efw, trange_wb) |> standardize\n    B = B[DimSelectors(E; selectors=Near())]\n\n    E_clean = replace_outliers(E; window=128)\n    B_sm = tfilter(B, 64u\"Hz\")\n    E_clean_sm = tfilter(tinterp_nans(E_clean), 64u\"Hz\")\n\n    S = Poynting_vector(B, E)\n    S_sm = Poynting_vector(B_sm, E_clean_sm)\n\n    f = Figure()\n    tplot(f[1, 1:2], [thm_scw_dsl, thm_efw])\n    tplot(f[2:4, 1], [B, E, S])\n    tplot(f[2:4, 2], [B_sm, E_clean_sm, S_sm])\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌ Warning: (DimensionalData.Dimensions.Dim{:the_efw},) dims were not found in object.\n└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/M9vEC/src/Dimensions/primitives.jl:844\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 1.0)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 1.0)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n[ Info: Resampling array of size (63403, 3) along dimension 1 from 63403 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n[ Info: Resampling array of size (63915, 3) along dimension 1 from 63915 to 6070 points\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-17-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\n#### Frequency-Domain Calculation of Poynting Flux\n\nFrom top to bottom, the panels show the Poynting flux and its corresponding frequency spectra in the x, y, z directions and magnitude, respectively.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nlet S = tnorm_combine(S_sm)\n    S_dpwrspc = pspectrum(S; nfft=512) |> SpaceTools.set_colorrange\n    f = tplot([\n        S,\n        eachslice(S_dpwrspc; dims=Y())...\n    ])\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n┌ Warning: Time resolution is is not approximately constant (relerr ≈ 0.0020964360587002098)\n└ @ SpaceTools ~/.julia/dev/SpaceTools/src/timeseries.jl:23\n[ Info: Resampling array of size (63915, 4) along dimension 1 from 63915 to 6070 points\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-18-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\n\n## Appendix\n\nCore codes is pasted here for reference (which is readable to some extent:).\n\n```julia\n\"\"\"\n    spectral_matrix(X, window)\n\"\"\"\nfunction spectral_matrix(X::AbstractMatrix, window::AbstractVector=ones(size(X, 1)))\n    n_samples, n = size(X)\n\n    # Apply the window to each component\n    Xw = X .* window\n\n    # Compute FFTs and normalize\n    Xf = fft(Xw, 1) ./ sqrt(n_samples)\n\n    # Only keep the positive frequencies\n    Nfreq = div(n_samples, 2)\n    Xf = Xf[1:Nfreq, :]\n\n    S = Array{ComplexF64,3}(undef, Nfreq, n, n)\n    for i in 1:n, j in 1:n\n        @. S[:, i, j] = Xf[:, i] * conj(Xf[:, j])\n    end\n\n    return S\nend\n\n\"\"\"\n    wavpol(ct, X; nfft=256, noverlap=nfft÷2, bin_freq=3)\n\nPerform polarization analysis of `n`-component time series data.\n\nAssumes the data are in a right-handed, field-aligned coordinate system \n(with Z along the ambient magnetic field).\n\nFor each FFT window (with specified overlap), the routine:\n  1. Computes the FFT and constructs the spectral matrix ``S(f)``.\n  2. Applies frequency smoothing using a window (of length `bin_freq`).\n  3. Computes the wave power, degree of polarization, wave normal angle,\n     ellipticity, and helicity.\n\n# Returns\nA tuple: where each parameter (except `freqline`) is an array with one row per FFT window.\n\"\"\"\nfunction wavpol(ct, X; nfft=256, noverlap=div(nfft, 2), bin_freq=3)\n    # Ensure the smoothing window length is odd.\n    iseven(bin_freq) && (bin_freq += 1)\n\n    N = size(X, 1)\n    samp_freq = samplingrate(ct)\n    Nfreq = div(nfft, 2)\n    fs = (samp_freq / nfft) * (0:(Nfreq-1))\n\n    # Define the number of FFT windows and times (center time of each window)\n    nsteps = floor(Int, (N - nfft) / noverlap) + 1\n    times = similar(ct, nsteps)\n\n    # Define the FFT window (here a smooth window similar to Hanning)\n    window = 0.08 .+ 0.46 .* (1 .- cos.(2π .* (0:(nfft-1)) ./ nfft))\n    half = div(nfft, 2)\n    # Use a Hamming window for frequency smoothing.\n    smooth_win = 0.54 .- 0.46 * cos.(2π .* (0:(bin_freq-1)) ./ (bin_freq - 1))\n    smooth_win = smooth_win / sum(smooth_win)\n\n    # Preallocate arrays for the results.\n    power = zeros(Float64, nsteps, Nfreq)\n    degpol = zeros(Float64, nsteps, Nfreq)\n    waveangle = zeros(Float64, nsteps, Nfreq)\n    ellipticity = zeros(Float64, nsteps, Nfreq)\n    helicity = zeros(Float64, nsteps, Nfreq)\n\n    # Process each FFT window.\n    Threads.@threads for j in 1:nsteps\n        start_idx = 1 + (j - 1) * noverlap\n        end_idx = start_idx + nfft - 1\n        if end_idx > N\n            continue\n        end\n        S = spectral_matrix(@view(X[start_idx:end_idx, :]), window)\n        S_smooth = smooth_spectral_matrix(S, smooth_win)\n        params = compute_polarization_parameters(S_smooth)\n\n        # Store the results.\n        power[j, :] = params.power\n        degpol[j, :] = params.degpol\n        waveangle[j, :] = params.waveangle\n        ellipticity[j, :] = params.ellipticity\n        helicity[j, :] = params.helicity\n        times[j] = ct[start_idx+half] # Set the times at the center of the FFT window.\n    end\n    return (; times, fs, power, degpol, waveangle, ellipticity, helicity)\nend\n```\n\n```julia\nfunction wpol_helicity(S::AbstractMatrix{ComplexF64}, waveangle::Number)\n    # Preallocate arrays for 3 polarization components\n    helicity_comps = zeros(Float64, 3)\n    ellip_comps = zeros(Float64, 3)\n\n    for comp in 1:3\n        # Build state vector λ_u for this polarization component\n        alph = sqrt(real(S[comp, comp]))\n        alph == 0.0 && continue\n        if comp == 1\n            lam_u = [\n                alph,\n                (real(S[1, 2]) / alph) + im * (-imag(S[1, 2]) / alph),\n                (real(S[1, 3]) / alph) + im * (-imag(S[1, 3]) / alph)\n            ]\n        elseif comp == 2\n            lam_u = [\n                (real(S[2, 1]) / alph) + im * (-imag(S[2, 1]) / alph),\n                alph,\n                (real(S[2, 3]) / alph) + im * (-imag(S[2, 3]) / alph)\n            ]\n        else\n            lam_u = [\n                (real(S[3, 1]) / alph) + im * (-imag(S[3, 1]) / alph),\n                (real(S[3, 2]) / alph) + im * (-imag(S[3, 2]) / alph),\n                alph\n            ]\n        end\n\n        # Compute the phase rotation (gammay) for this state vector\n        lam_y = phase_factor(lam_u) * lam_u\n\n        # Helicity: ratio of the norm of the imaginary part to the real part\n        norm_real = norm(real(lam_y))\n        norm_imag = norm(imag(lam_y))\n        helicity_comps[comp] = (norm_imag != 0) ? norm_imag / norm_real : NaN\n\n        # For ellipticity, use only the first two components\n        u1 = lam_y[1]\n        u2 = lam_y[2]\n\n        # TODO: why there is no 2 in front of uppere?\n        uppere = imag(u1) * real(u1) + imag(u2) * real(u2)\n        lowere = (-imag(u1)^2 + real(u1)^2 - imag(u2)^2 + real(u2)^2)\n        gammarot = atan(uppere, lowere)\n        lam_urot = exp(-1im * 0.5 * gammarot) * [u1, u2]\n\n        num = norm(imag(lam_urot))\n        den = norm(real(lam_urot))\n        ellip_val = (den != 0) ? num / den : NaN\n        # Adjust sign using the off-diagonal of ematspec and the wave normal angle\n        sign_factor = sign(imag(S[1, 2]) * sin(waveangle))\n        ellip_comps[comp] = ellip_val * sign_factor\n    end\n\n    # Average the three computed values\n    helicity = mean(helicity_comps)\n    ellipticity = mean(ellip_comps)\n\n    return helicity, ellipticity\nend\n```\n\n\n## References\n\nSearch Coil Magnetometer (SCM) science data\n\n- WB waveforms (scw) [8192 S/s]\n\n- https://themis.igpp.ucla.edu/scm_dataflow.shtml\n\nElectric Field Instruments (EFI) science data\n\n- PB waveforms (efp, vap) [128 S/s; Allocation ~ 1.2h]  \n- WB waveforms (efw, vaw) [8192 S/s; Allocation ~ 43s]\n\n- https://themis.ssl.berkeley.edu/instrument_efi.shtml\n\n",
    "supporting": [
      "ps5_files/figure-typst"
    ],
    "filters": []
  }
}