{
  "hash": "13e8a7b5ee6426637aba8ca7fc23a4e2",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Problem Set 5\nengine: julia\n---\n\n## A whistler mode chorus event\n\n> Obtain and analyze DC and AC wave data for an event, including wave polarization and Poynting flux. A whistler mode chorus event observed by THEMIS, occurred on TH-E (P5) at ~10:00-10:15 UT on 2008-12-15 (referenced in the class notes in Lecture 10, p.5) taken from the paper by Li et al., JGR 2011.\n\n> In the overview plots (here and here), E & B wavepower is significant during significant velocity oscillations. A different whistler mode chorus event was observed by MMS on 2019-08-16 at ~09:32:00UT within a flux pileup region shown in Fig. 2 of Fu et al., GRL 2025. MMS overview plot is here. Follow the structure of Hwk05_01.pro (just an example). Work in either IDL or PySPEDAS, for either the THEMIS or the MMS event to:\n\n> - Fig. 1. Identify the event in overview plots and point out the wave power related to it\n> - Fig. 2. Get the Electric Field (Double-Probe) Instruments (EFI) data, remove offsets, show ExB velocity, using E*B=0 approximation\n> - Fig. 3. Plot on-board computed spectra. Overplot fce, 1â„2 fce\n> - Fig. 4. Recognize (wave)burst times in the waveforms and plot them and the spectra\n> - Fig. 5. Introduce E and B and show ground computed spectra (wavelet and Fourier)\n> - Fig. 6. Rotate into FAC coordâ€™s and feed waveforms into wave analysis program. Plot results. Read the section of the relevant paper and explain the role/significance of the whistler waves in their respective setting.\n> - Fig. 7. Show the Poynting flux for the band-passed signal. Do this is time domain (process time series in real space) and in frequency domain (using the available tools).  \n> Deliver a report explaining what you did, and your code.\n\n### Identification in overview plots\n\n@liModulationWhistlerMode2011\n\n![[overview summary](https://themis.ssl.berkeley.edu/summary.php?year=2008&month=12&day=15&hour=1012&sumType=the&type=overview)](https://themis.ssl.berkeley.edu/themisdata/overplots/2008/12/15/the_l2_overview_20081215_1012.png)\n\nWe can clearly observe from the overview plot, specifically in the final panel, that the FBK exhibits wave activity within the frequency range of approximately 10â€“100 Hz. Additionally, it is evident that this wave activity is modulated with a period of roughly 10 seconds.\n\n![[moms summary](https://themis.ssl.berkeley.edu/summary.php?year=2008&month=12&day=15&hour=1012&sumType=the&type=moms)](https://themis.ssl.berkeley.edu/themisdata/overplots/2008/12/15/the_l2_moms_20081215_1012.png)\n\nSimilarly, the pressure, magnetic field, temperature, and electron density measurements also exhibit oscillations with a comparable period.\n\n### Electric field data\n\n> Get the Electric Field (Double-Probe) Instruments (EFI) data, remove offsets, show ExB velocity, using E*B=0 approximation\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndir = \"docs/courses/epss261/homework\"\nif isdir(dir)\n    cd(dir)\n    Pkg.activate(\".\")\n    Pkg.resolve()\n    Pkg.instantiate()\nend\n```\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Speasy\nusing CairoMakie\nusing Dates\nusing SpacePhysicsMakie\nusing LinearAlgebra\nusing Statistics\nusing DimensionalData\nusing Unitful\nusing PlasmaFormulary\nusing SignalAnalysis\nusing SPEDAS, TimeseriesUtilities\nusing Speasy: get_data\nSpacePhysicsMakie.DEFAULTS.add_title = true\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/DimensionalData/FWnw9/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/Speasy/zZJZI/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/CondaPkg/0UqYV/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/PythonCall/83z4q/CondaPkg.toml\n    CondaPkg Found dependencies: /Users/zijin/.julia/packages/PySPEDAS/IGdx7/CondaPkg.toml\n    CondaPkg Initialising pixi\n             â”‚ /Users/zijin/.julia/artifacts/d2fecc2a9fa3eac2108d3e4d9d155e6ff5dfd0b2/bin/pixi\n             â”‚ init\n             â”‚ --format pixi\n             â”” /Users/zijin/projects/beforerr/docs/courses/epss261/homework/.CondaPkg\nâœ” Created /Users/zijin/projects/beforerr/docs/courses/epss261/homework/.CondaPkg/pixi.toml\n    CondaPkg Wrote /Users/zijin/projects/beforerr/docs/courses/epss261/homework/.CondaPkg/pixi.toml\n             â”‚ [dependencies]\n             â”‚ netcdf4 = \"*\"\n             â”‚ uv = \">=0.4\"\n             â”‚ xarray = \"*\"\n             â”‚ sqlite = \"!=3.49.1\"\n             â”‚ numpy = \"*\"\n             â”‚ \n             â”‚     [dependencies.python]\n             â”‚     channel = \"conda-forge\"\n             â”‚     build = \"*cp*\"\n             â”‚     version = \">=3.10,!=3.14.0,!=3.14.1,<4, 3.13.*\"\n             â”‚ \n             â”‚ [project]\n             â”‚ name = \".CondaPkg\"\n             â”‚ platforms = [\"osx-arm64\"]\n             â”‚ channels = [\"conda-forge\"]\n             â”‚ channel-priority = \"strict\"\n             â”‚ description = \"automatically generated by CondaPkg.jl\"\n             â”‚ \n             â”‚ [pypi-dependencies.speasy]\n             â”‚ git = \"https://github.com/SciQLop/speasy\"\n             â”‚ \n             â”‚ [pypi-dependencies.pyspedas]\n             â”” git = \"https://github.com/spedas/pyspedas\"\n    CondaPkg Installing packages\n             â”‚ /Users/zijin/.julia/artifacts/d2fecc2a9fa3eac2108d3e4d9d155e6ff5dfd0b2/bin/pixi\n             â”‚ install\n             â”” --manifest-path /Users/zijin/projects/beforerr/docs/courses/epss261/homework/.CondaPkg/pixi.toml\n WARN Using local manifest /Users/zijin/projects/beforerr/docs/courses/epss261/homework/.CondaPkg/pixi.toml rather than /Users/zijin/projects/beforerr/pyproject.toml from environment variable `PIXI_PROJECT_MANIFEST`\nâœ” The default environment has been installed.\nPrecompiling packages...\nInfo Given SPEDAS was explicitly requested, output will be shown live \nWARNING: Method definition name2dim(Base.Val{:ð‘“}) in module PlasmaWavesDimensionalDataExt at /Users/zijin/.julia/packages/DimensionalData/FWnw9/src/Dimensions/dimension.jl:477 overwritten in module SPEDAS on the same line (check for duplicate calls to `include`).\nERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.\n   4563.6 ms  ? SPEDAS\nWARNING: Method definition name2dim(Base.Val{:ð‘“}) in module PlasmaWavesDimensionalDataExt at /Users/zijin/.julia/packages/DimensionalData/FWnw9/src/Dimensions/dimension.jl:477 overwritten in module SPEDAS on the same line (check for duplicate calls to `include`).\nERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntrange_plus = (\"2008-12-15T09:45:00\", \"2008-12-15T10:30:00\")\ntrange = (\"2008-12-15T09:55:00\", \"2008-12-15T10:20:00\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(\"2008-12-15T09:55:00\", \"2008-12-15T10:20:00\")\n```\n:::\n:::\n\n\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\n\"\"\"\nReference: [SPEDAS](https://github.com/spedas/bleeding_edge/blob/master/idl/projects/themis/spacecraft/fields/thm_load_fit.pro)\n\"\"\"\nfunction thm_load_fit(probe, timerange; vars=[\"fgs_dsl\", \"efs_dsl\", \"efs_0_dsl\", \"efs_dot0_dsl\"])\n    dataset = \"TH$(uppercase(probe))_L2_FIT\"\n    vars = \"th$(lowercase(probe))_\" .* vars\n    ids = \"cda/$dataset/\" .* vars\n    return map(DimArray, get_data(NamedTuple, ids, timerange))\nend\n\ndata = thm_load_fit(\"e\", trange)\ntplot(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get THE_L2_FIT/the_fgs_dsl without web service, switching to web service\nCan't get THE_L2_FIT/the_efs_dsl without web service, switching to web service\nCan't get THE_L2_FIT/the_efs_0_dsl without web service, switching to web service\nCan't get THE_L2_FIT/the_efs_dot0_dsl without web service, switching to web service\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-5-output-2.png){width=800 height=800}\n:::\n:::\n\n\n\nHere's the Julia equivalent of the provided IDL code for removing offsets and calculating electric field components:\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\n# Get Ez (dsl) and ExB\nlet B = data.the_fgs_dsl, E = data.the_efs_dsl, angle = 20.0  # degrees\n    # First get Ex/y offsets\n    println(\"Select 2 times (Start/Stop) for obtaining Ex, Ey offsets\")\n    trange4offset = [\"2008-12-15T10:30:00\", \"2008-12-15T10:40:00\"]\n\n    data_offset = thm_load_fit(\"e\", trange4offset)\n    Eoffsets = tmean(data_offset.the_efs_dsl)\n    @info \"Eoffsets\" Eoffsets.data\n\n    # Set angle threshold\n    tanangle = tan(angle * Ï€ / 180.0)\n\n    # Calculate the condition for each data point\n    B = B[DimSelectors(E)]\n    bxy_magnitude = sqrt.(B[:, 1] .^ 2 + B[:, 2] .^ 2)\n    angle_condition = abs.(B[:, 3] ./ bxy_magnitude) .>= tanangle\n    igood = findall(angle_condition)\n    ibad = findall(.!angle_condition)\n    janygood = length(igood)\n    janybad = length(ibad)\n    @info \"janygood\" janygood\n    @info \"janybad\" janybad\n    # Apply offsets to Ex and Ey components\n    E_corrected = copy(E)\n    E_corrected[:, 1] .-= Eoffsets[1]\n    E_corrected[:, 2] .-= Eoffsets[2]\n\n    # Set bad data points to NaN\n    if janybad >= 1\n        for i in ibad\n            E_corrected[i, :] .= NaN\n        end\n    end\n\n    if janygood < 1\n        println(\"*****WARNING: NO GOOD 3D ExB data\")\n    else\n        for i in igood\n            E_corrected[i, 3] =\n                -(E_corrected[i, 1] * B[i, 1] +\n                  E_corrected[i, 2] * B[i, 2]) /\n                B[i, 3]\n        end\n    end\n\n    f = Figure()\n    tplot(f[1, 1], data_offset)\n    tplot(f[1, 2:4], [B, E, E_corrected, data.the_efs_0_dsl, data.the_efs_dot0_dsl])\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSelect 2 times (Start/Stop) for obtaining Ex, Ey offsets\nCan't get THE_L2_FIT/the_fgs_dsl without web service, switching to web service\nCan't get THE_L2_FIT/the_efs_dsl without web service, switching to web service\nCan't get THE_L2_FIT/the_efs_0_dsl without web service, switching to web service\nCan't get THE_L2_FIT/the_efs_dot0_dsl without web service, switching to web service\nâ”Œ Info: Eoffsets\nâ”‚   Eoffsets.data =\nâ”‚    3-element Vector{Float32}:\nâ”‚      -0.9041299\nâ”‚       0.07251182\nâ””     -25.993834\nâ”Œ Info: janygood\nâ””   janygood = 489\nâ”Œ Info: janybad\nâ””   janybad = 0\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-6-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\nIn the left panel, we present the data utilized for the offset analysis. In the right panel, arranged sequentially from top to bottom, we display the magnetic field data, the electric field data, the electric field data corrected using our offset analysis, and finally, the corresponding electric field data extracted from the L2 dataset `efs_0_dsl` and `efs_dot0_dsl`.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nlet E = data.the_efs_dot0_dsl, B = data.the_fgs_dsl\n    B_int = tinterp(B, E)\n    V = tcross(E, B_int) ./ tdot(B_int, B_int) * 1000u\"km/s\"\n    V = setmeta(V, \"LABLAXIS\" => \"Velocity\", \"UNITS\" => \"km/s\"; labels=(\"Vx\", \"Vy\", \"Vz\"))\n    tplot([B, E, V])\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-7-output-1.png){width=800 height=600}\n:::\n:::\n\n\n\nComputed $V= E Ã— B/B^2$ is shown in the last panel.\n\n### On-board computed spectra\n\n> Plot on-board computed spectra. Overplot fce, 1â„2 fce\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction thm_load_fbk(probe, timerange; vars=(\"fb_edc12\", \"fb_scm1\"))\n    dataset = \"TH$(uppercase(probe))_L2_FBK\"\n    vars = \"th$(lowercase(probe))_\" .* vars\n    ids = \"cda/$dataset/\" .* vars\n    DimArray.(get_data(ids, timerange))\nend\n\nthm_fb_edc12, thm_fb_scm1 = thm_load_fbk(\"e\", trange)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get THE_L2_FBK/the_fb_edc12 without web service, switching to web service\nCan't get THE_L2_FBK/the_fb_scm1 without web service, switching to web service\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{DimMatrix{Float32, Tuple{Ti{DimensionalData.Dimensions.Lookups.Sampled{UnixTimes.UnixTime, VariableAxis{UnixTimes.UnixTime, 1}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Irregular{Tuple{Nothing, Nothing}}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}, Y{DimensionalData.Dimensions.Lookups.Sampled{Float32, VariableAxis{Float32, 1}, DimensionalData.Dimensions.Lookups.ReverseOrdered, DimensionalData.Dimensions.Lookups.Irregular{Tuple{Nothing, Nothing}}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}}, Tuple{}, PythonCall.PyArray{Float32, 2, true, false, Float32}, String, Speasy.OverlayDict{Union{String, Symbol}, Any}}}:\n Float32[0.014709114 0.0073833982 â€¦ 0.012690215 0.01730484; 0.014709114 0.020304345 â€¦ 0.009229247 0.01730484; â€¦ ; 0.014709114 0.0 â€¦ 0.008075591 0.01730484; 0.0 0.0 â€¦ 0.013843872 0.020765807]\n Float32[0.0032959487 0.00077439536 â€¦ 0.003418021 0.0085832; 0.0032959487 0.00077439536 â€¦ 0.0028839551 0.009536888; â€¦ ; 0.0032959487 0.00082780194 â€¦ 0.0023498894 0.0014305334; 0.00343328 0.00082780194 â€¦ 0.0024567025 0.0071526663]\n```\n:::\n:::\n\n\n\nThe three lines in Figures represent 1 fce (blue), 0.5 fce (orange), and 0.1 fce (green).\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nlet B = tnorm(data.the_fgs_dsl) * 1u\"nT\"\n    fce = gyrofrequency.(B, :e) .|> Ï‰2f\n    fce = setmeta(fce, scale=log10) ./ 1u\"Hz\"\n    f = tplot([thm_fb_edc12, thm_fb_scm1]; add_title=true, alpha=0.7)\n    tplot_panel!.(f.axes, Ref([fce, fce / 2, fce / 10]))\n    f\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-9-output-1.png){width=800 height=600}\n:::\n:::\n\n\n\n`ffw_16_eac34` and `ffp_16_eac34` `ffp_16_scm3` data are not available for this event.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction thm_load_fft(probe, timerange; vars=(\"ffw_16_eac34\", \"ffp_16_eac34\", \"ffp_16_scm3\"))\n    dataset = \"TH$(uppercase(probe))_L2_FFT\"\n    vars = \"th$(lowercase(probe))_\" .* vars\n    ids = \"cda/$dataset/\" .* vars\n    DimArray.(get_data(ids, timerange))\nend\n\nfft_tvars = [\n    \"cda/THE_L2_FFT/the_ffp_16_eac34\",\n    \"cda/THE_L2_FFT/the_ffp_16_scm3\",\n    \"cda/THE_L2_FFT/the_ffw_16_eac34\",\n    \"cda/THE_L2_FFT/the_ffw_16_scm3\",\n]\n\nfft_data = get_data.(fft_tvars, (trange,))\nall(ismissing.(fft_data)) && @warn \"Data not available\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get THE_L2_FFT/the_ffp_16_eac34 without web service, switching to web service\nCan't get THE_L2_FFT/the_ffp_16_scm3 without web service, switching to web service\nCan't get THE_L2_FFT/the_ffw_16_eac34 without web service, switching to web service\nCan't get THE_L2_FFT/the_ffw_16_scm3 without web service, switching to web service\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfalse\n```\n:::\n:::\n\n\n\n\n### Waveburst and spectra\n\n> Recognize (wave)burst times in the waveforms and plot them and the spectra.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntvars = [\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n    \"cda/THE_L2_SCM/the_scw_dsl\",\n]\n\nthm_scp_dsl, thm_scw_dsl = get_data.(tvars, (trange_plus,)) .|> DimArray\nf = Figure()\ntplot(f[1, 1], [thm_scp_dsl, thm_scw_dsl])\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get THE_L2_SCM/the_scp_dsl without web service, switching to web service\nCan't get THE_L2_SCM/the_scw_dsl without web service, switching to web service\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-11-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\nWe see a waveburst around 2008-12-15T10:13:10.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\ntvars_wb = [\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n    \"cda/THE_L2_SCM/the_scw_dsl\",\n    \"cda/THE_L2_FBK/the_fb_scm1\",\n]\ntrange_wb = DateTime.((\"2008-12-15T10:13:10\", \"2008-12-15T10:13:20\"))\ntrange_wb_s = (\"2008-12-15T10:13:10\", \"2008-12-15T10:13:17\")\ndata_wb = get_data.(tvars_wb, (trange_wb,)) .|> DimArray\n# tplot(f[1, 2], data_wb)\ntplot(f[1, 2], data_wb)\ntlims!(trange_wb_s)\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get THE_L2_SCM/the_scp_dsl without web service, switching to web service\nCan't get THE_L2_SCM/the_scw_dsl without web service, switching to web service\nCan't get THE_L2_FBK/the_fb_scm1 without web service, switching to web service\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-12-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\n\n### Ground computed spectra\n\n> Introduce E and B and show ground computed spectra (wavelet and Fourier)\n\n```julia\nusing PySPEDAS.Projects\nthm_efi_ds = themis.efi(trange, level=\"l1\", probe=\"e\")\nthm_efw = DimArray(thm_efi_ds.the_efw)\n```\n\nLoading `efw` data using `PySPEDAS` is somehow quite slow, instead we define a configuration file and load the `efw` data from the SPDF.\n\n```{yaml}\nthe_efw_l1:\n  inventory_path: spdf/THEMIS/THE/L1/EFW\n  master_cdf: https://spdf.gsfc.nasa.gov/pub/data/themis/the/l1/efw/2021/the_l1_efw_20210102_v01.cdf\n  split_frequency: daily\n  split_rule: regular\n  url_pattern: https://spdf.gsfc.nasa.gov/pub/data/themis/the/l1/efw/{Y}/the_l1_efw_{Y}{M:02d}{D:02d}_v\\d+.cdf\n  use_file_list: true\n```\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nthe_efw_l1_index = speasy.inventories.data_tree.archive.spdf.THEMIS.THE.L1.EFW.the_efw_l1\ntvars = [\n    \"cda/THE_L2_FGM/the_fgs_gsm\",\n    \"cda/THE_L2_FGM/the_fgh_gsm\",\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n    \"cda/THE_L2_SCM/the_scw_dsl\"\n]\nthm_fgs_gsm, thm_fgh_gsm, thm_scp_dsl, thm_scw_dsl = get_data(tvars, trange_plus) .|> DimArray\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get THE_L2_FGM/the_fgs_gsm without web service, switching to web service\nCan't get THE_L2_FGM/the_fgh_gsm without web service, switching to web service\nCan't get THE_L2_SCM/the_scp_dsl without web service, switching to web service\nCan't get THE_L2_SCM/the_scw_dsl without web service, switching to web service\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{DimMatrix{Float32, Tuple{Ti{DimensionalData.Dimensions.Lookups.Sampled{UnixTimes.UnixTime, VariableAxis{UnixTimes.UnixTime, 1}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Irregular{Tuple{Nothing, Nothing}}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}, Y{DimensionalData.Dimensions.Lookups.Sampled{Int32, VariableAxis{Int32, 1}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Irregular{Tuple{Nothing, Nothing}}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.NoMetadata}}}, Tuple{}, PythonCall.PyArray{Float32, 2, true, false, Float32}, String, Speasy.OverlayDict{Union{String, Symbol}, Any}}}:\n Float32[-6.884452 2.770554 13.2441; -6.8816504 2.699388 13.368085; â€¦ ; -10.854679 -2.0566497 25.193708; -11.012929 -1.8605247 25.144516]\n Float32[-4.202244 1.5139444 15.179175; -4.1365685 1.664007 15.140432; â€¦ ; -8.527703 -0.975849 22.252335; -8.648017 -1.0026835 22.07751]\n Float32[-7.3053866f-6 -1.8908788f-5 -2.836187f-5; -7.3053866f-6 -1.8908788f-5 -2.836187f-5; â€¦ ; 4.3625614f-6 5.230054f-6 -9.406129f-6; 4.3625614f-6 5.230054f-6 -9.406129f-6]\n Float32[-0.000119733224 0.00037838318 -0.00024678188; -0.000119733224 0.00037838318 -0.00024678188; â€¦ ; 0.0017912713 -0.0006972916 0.0004022404; 0.0017912713 -0.0006972916 0.0004022404]\n```\n:::\n:::\n\n\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nthm_fgs_gsm_z_dpwrspc = SPEDAS.pspectrum(thm_fgs_gsm[:, 3]; nfft=64) |> SpacePhysicsMakie.set_colorrange!\nthm_scp_dsl_z_dpwrspc = SPEDAS.pspectrum(thm_scp_dsl[:, 3]; nfft=512) |> SpacePhysicsMakie.set_colorrange!\nthm_fgh_gsm_z_dpwrspc = SPEDAS.pspectrum(thm_fgh_gsm[:, 3]) |> SpacePhysicsMakie.set_colorrange!\n# SpaceTools.set_colorrange\n\ntvars_wb = [\n    the_efw_l1_index.the_efw,\n    \"cda/THE_L2_SCM/the_scw_dsl\"\n]\n\nthm_efw, thm_scw_dsl = get_data.(tvars_wb, (trange_wb,)) .|> DimArray\n\nthm_scw_dsl_z_dpwrspc = SPEDAS.pspectrum(thm_scw_dsl[:, 3]) |> SpacePhysicsMakie.set_colorrange!\nthm_efw_z_dpwrspc = SPEDAS.pspectrum(thm_efw[:, 3]) |> SpacePhysicsMakie.set_colorrange!\n\nf = Figure()\ntplot(f[1, 1], [\n    thm_fgs_gsm, thm_fgs_gsm_z_dpwrspc,\n    thm_fgh_gsm, thm_fgh_gsm_z_dpwrspc,\n    thm_scp_dsl, thm_scp_dsl_z_dpwrspc,\n])\n\ntplot(f[1, 2], [\n    thm_scw_dsl, thm_scw_dsl_z_dpwrspc,\n    thm_efw, thm_efw_z_dpwrspc,\n])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 511.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 512.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nCan't get THE_L2_SCM/the_scw_dsl without web service, switching to web service\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.0020964360587002098)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-14-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\nDuring the interval when we have wavebursts, the whistle wave is clearly identifiable in the SCP data. However, in the higher-frequency data product, it becomes difficult to discern any distinct signatures within the spectrogram.\n\n### FAC coordinate\n\n> Rotate into FAC coordâ€™s and feed waveforms into wave analysis program. Plot results. Read the section of the relevant paper and explain the role/significance of the whistler waves in their respective setting.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\ntvars = [\n    \"cda/THE_L2_FGM/the_fgs_dsl\",\n    \"cda/THE_L2_FGM/the_fgh_dsl\",\n    \"cda/THE_L2_SCM/the_scp_dsl\",\n]\n_trange = [\"2008-12-15T09:59\", \"2008-12-15T10:13\"]\n\nthm_fgs_dsl, thm_fgh_dsl, thm_scp_dsl = Speasy.get_data(tvars, _trange) .|> DimArray\n\nfac_mats = tfac_mat(thm_fgs_dsl)\nthm_scp_fac = select_rotate(thm_scp_dsl, fac_mats, \"FAC\")\nthm_fgh_fac = select_rotate(thm_fgh_dsl, fac_mats, \"FAC\")\n\nf = Figure()\n\ntplot(f[1, 1], [\n    thm_fgs_dsl,\n    thm_fgh_dsl,\n    thm_scp_dsl,\n])\ntplot(f[1, 2], [\n    thm_fgh_fac,\n    thm_scp_fac,\n])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get THE_L2_FGM/the_fgs_dsl without web service, switching to web service\nCan't get THE_L2_FGM/the_fgh_dsl without web service, switching to web service\nCan't get THE_L2_SCM/the_scp_dsl without web service, switching to web service\nâ”Œ Warning: (DimensionalData.Dimensions.Y,) dims were not found in object.\nâ”” @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/FWnw9/src/Dimensions/primitives.jl:852\nâ”Œ Warning: (DimensionalData.Dimensions.Y,) dims were not found in object.\nâ”” @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/FWnw9/src/Dimensions/primitives.jl:852\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-15-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\n#### Wave polarization analysis\n\n::: {.cell .column-page fig-width='15' execution_count=1}\n``` {.julia .cell-code}\nf = Figure(;)\ntplot(f[1, 1], thm_fgh_fac)\ntplot(f[2:6, 1], twavpol(tresample(thm_fgh_fac)))\ntplot(f[1, 2], thm_scp_fac)\ntplot(f[2:6, 2], twavpol(tresample(thm_scp_fac)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 512.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-16-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\nCompressional pulsations are associated with modulations of resonant electron fluxes and chorus intensity.\n\nWe have developed a high-performance wave polarization program implemented in Julia, achieving a significant speedup of approximately 100 times compared to its Python counterpart. Furthermore, our implementation is more generalizable, extending the original programâ€™s capabilities to accommodate data in n dimensions. The program is accessible via the following link:\n\n- https://beforerr.github.io/SpaceTools.jl/dev/explanations/waves/\n- https://beforerr.github.io/SpaceTools.jl/dev/validation/pyspedas/\n\nCore part is attached in the appendix.\n\n###  Poynting flux\n\n- [thm_crib_poynting_flux.pro](https://github.com/spedas/bleeding_edge/blob/master/projects/themis/examples/advanced/thm_crib_poynting_flux.pro)\n- [thm_efi_clean_efw.pro](https://github.com/spedas/bleeding_edge/blob/8714f1b9c390780619403f2c56c35f5be675b34b/projects/themis/spacecraft/fields/LASP/thm_efi_clean_efw.pro)\n\nFrom top to bottom, we present the original data, the cleaned data with spikes removed, and the filtered data.\n\nThe right panel provides a magnified view of the data presented in the left panel\n\nWe can see that removing spikes is essential for the accuracy of the filtered data.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nusing TimeseriesUtilities: tfilter\nbegin\n    window = 128\n    E = Float64.(tclip(thm_efw, trange_wb))\n    E_clean = replace_outliers(E; window)\n    E_sm = tfilter(E, 64u\"Hz\")\n    E_clean_sm = tfilter(tinterp_nans(E_clean), 64u\"Hz\")\n\n    tvars = [E, E_clean, E_sm, E_clean_sm] .|> tshift\n    f = Figure()\n    tplot(f[1, 1], tvars)\n    fa2 = tplot(f[1, 2], tvars; link_yaxes=true)\n    t0 = E_clean |> tminimum\n    tlims!.(fa2.axes, 3.44u\"s\", 3.48u\"s\")\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.0020964360587002098)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.0020964360587002098)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.0020964360587002098)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.0020964360587002098)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-17-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nPoynting_vector(E, B) = setmeta(tcross(E, B) ./ Unitful.Î¼0, \"LABL_PTR_1\" => [\"Sx\", \"Sy\", \"Sz\"], \"UNITS\" => \"nW/m^2\")\n\nbegin\n    B = tclip(thm_scw_dsl, trange_wb)\n    E = Float64.(tclip(thm_efw, trange_wb))\n    B = B[DimSelectors(E; selectors=Near())]\n\n    E_clean = replace_outliers(E; window=128)\n    B_sm = tfilter(B, 64u\"Hz\")\n    E_clean_sm = tfilter(tinterp_nans(E_clean), 64u\"Hz\")\n\n    S = Poynting_vector(B, E)\n    S_sm = Poynting_vector(B_sm, E_clean_sm)\n\n    f = Figure()\n    tplot(f[1, 1:2], [thm_scw_dsl, thm_efw])\n    tplot(f[2:4, 1], [B, E, S])\n    tplot(f[2:4, 2], [B_sm, E_clean_sm, S_sm])\n    f\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 1.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 1.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.0020964360587002098)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 0.0020964360587002098)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-18-output-2.png){width=960 height=672}\n:::\n:::\n\n\n\n#### Frequency-Domain Calculation of Poynting Flux\n\nFrom top to bottom, the panels show the Poynting flux and its corresponding frequency spectra in the x, y, z directions and magnitude, respectively.\n\n::: {.cell .column-page execution_count=1}\n``` {.julia .cell-code}\nlet S = tnorm_combine(S_sm)\n    S_dpwrspc = pspectrum(S; nfft=512) |> SpacePhysicsMakie.set_colorrange!\n    f = tplot([\n        S,\n        eachslice(S_dpwrspc; dims=Y())...\n    ])\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 1.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 1.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 1.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\nâ”Œ Warning: Time resolution is is not approximately constant (relerr â‰ˆ 1.0)\nâ”” @ TimeseriesUtilities ~/.julia/dev/TimeseriesUtilities/src/timeseries.jl:5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps5_files/figure-typst/cell-19-output-2.png){width=800 height=1000}\n:::\n:::\n\n\n\n\n## Appendix\n\nCore codes is pasted here for reference (which is readable to some extent:).\n\n```julia\n\"\"\"\n    spectral_matrix(X, window)\n\"\"\"\nfunction spectral_matrix(X::AbstractMatrix, window::AbstractVector=ones(size(X, 1)))\n    n_samples, n = size(X)\n\n    # Apply the window to each component\n    Xw = X .* window\n\n    # Compute FFTs and normalize\n    Xf = fft(Xw, 1) ./ sqrt(n_samples)\n\n    # Only keep the positive frequencies\n    Nfreq = div(n_samples, 2)\n    Xf = Xf[1:Nfreq, :]\n\n    S = Array{ComplexF64,3}(undef, Nfreq, n, n)\n    for i in 1:n, j in 1:n\n        @. S[:, i, j] = Xf[:, i] * conj(Xf[:, j])\n    end\n\n    return S\nend\n\n\"\"\"\n    wavpol(ct, X; nfft=256, noverlap=nfftÃ·2, bin_freq=3)\n\nPerform polarization analysis of `n`-component time series data.\n\nAssumes the data are in a right-handed, field-aligned coordinate system \n(with Z along the ambient magnetic field).\n\nFor each FFT window (with specified overlap), the routine:\n  1. Computes the FFT and constructs the spectral matrix ``S(f)``.\n  2. Applies frequency smoothing using a window (of length `bin_freq`).\n  3. Computes the wave power, degree of polarization, wave normal angle,\n     ellipticity, and helicity.\n\n# Returns\nA tuple: where each parameter (except `freqline`) is an array with one row per FFT window.\n\"\"\"\nfunction wavpol(ct, X; nfft=256, noverlap=div(nfft, 2), bin_freq=3)\n    # Ensure the smoothing window length is odd.\n    iseven(bin_freq) && (bin_freq += 1)\n\n    N = size(X, 1)\n    samp_freq = samplingrate(ct)\n    Nfreq = div(nfft, 2)\n    fs = (samp_freq / nfft) * (0:(Nfreq-1))\n\n    # Define the number of FFT windows and times (center time of each window)\n    nsteps = floor(Int, (N - nfft) / noverlap) + 1\n    times = similar(ct, nsteps)\n\n    # Define the FFT window (here a smooth window similar to Hanning)\n    window = 0.08 .+ 0.46 .* (1 .- cos.(2Ï€ .* (0:(nfft-1)) ./ nfft))\n    half = div(nfft, 2)\n    # Use a Hamming window for frequency smoothing.\n    smooth_win = 0.54 .- 0.46 * cos.(2Ï€ .* (0:(bin_freq-1)) ./ (bin_freq - 1))\n    smooth_win = smooth_win / sum(smooth_win)\n\n    # Preallocate arrays for the results.\n    power = zeros(Float64, nsteps, Nfreq)\n    degpol = zeros(Float64, nsteps, Nfreq)\n    waveangle = zeros(Float64, nsteps, Nfreq)\n    ellipticity = zeros(Float64, nsteps, Nfreq)\n    helicity = zeros(Float64, nsteps, Nfreq)\n\n    # Process each FFT window.\n    Threads.@threads for j in 1:nsteps\n        start_idx = 1 + (j - 1) * noverlap\n        end_idx = start_idx + nfft - 1\n        if end_idx > N\n            continue\n        end\n        S = spectral_matrix(@view(X[start_idx:end_idx, :]), window)\n        S_smooth = smooth_spectral_matrix(S, smooth_win)\n        params = compute_polarization_parameters(S_smooth)\n\n        # Store the results.\n        power[j, :] = params.power\n        degpol[j, :] = params.degpol\n        waveangle[j, :] = params.waveangle\n        ellipticity[j, :] = params.ellipticity\n        helicity[j, :] = params.helicity\n        times[j] = ct[start_idx+half] # Set the times at the center of the FFT window.\n    end\n    return (; times, fs, power, degpol, waveangle, ellipticity, helicity)\nend\n```\n\n```julia\nfunction wpol_helicity(S::AbstractMatrix{ComplexF64}, waveangle::Number)\n    # Preallocate arrays for 3 polarization components\n    helicity_comps = zeros(Float64, 3)\n    ellip_comps = zeros(Float64, 3)\n\n    for comp in 1:3\n        # Build state vector Î»_u for this polarization component\n        alph = sqrt(real(S[comp, comp]))\n        alph == 0.0 && continue\n        if comp == 1\n            lam_u = [\n                alph,\n                (real(S[1, 2]) / alph) + im * (-imag(S[1, 2]) / alph),\n                (real(S[1, 3]) / alph) + im * (-imag(S[1, 3]) / alph)\n            ]\n        elseif comp == 2\n            lam_u = [\n                (real(S[2, 1]) / alph) + im * (-imag(S[2, 1]) / alph),\n                alph,\n                (real(S[2, 3]) / alph) + im * (-imag(S[2, 3]) / alph)\n            ]\n        else\n            lam_u = [\n                (real(S[3, 1]) / alph) + im * (-imag(S[3, 1]) / alph),\n                (real(S[3, 2]) / alph) + im * (-imag(S[3, 2]) / alph),\n                alph\n            ]\n        end\n\n        # Compute the phase rotation (gammay) for this state vector\n        lam_y = phase_factor(lam_u) * lam_u\n\n        # Helicity: ratio of the norm of the imaginary part to the real part\n        norm_real = norm(real(lam_y))\n        norm_imag = norm(imag(lam_y))\n        helicity_comps[comp] = (norm_imag != 0) ? norm_imag / norm_real : NaN\n\n        # For ellipticity, use only the first two components\n        u1 = lam_y[1]\n        u2 = lam_y[2]\n\n        # TODO: why there is no 2 in front of uppere?\n        uppere = imag(u1) * real(u1) + imag(u2) * real(u2)\n        lowere = (-imag(u1)^2 + real(u1)^2 - imag(u2)^2 + real(u2)^2)\n        gammarot = atan(uppere, lowere)\n        lam_urot = exp(-1im * 0.5 * gammarot) * [u1, u2]\n\n        num = norm(imag(lam_urot))\n        den = norm(real(lam_urot))\n        ellip_val = (den != 0) ? num / den : NaN\n        # Adjust sign using the off-diagonal of ematspec and the wave normal angle\n        sign_factor = sign(imag(S[1, 2]) * sin(waveangle))\n        ellip_comps[comp] = ellip_val * sign_factor\n    end\n\n    # Average the three computed values\n    helicity = mean(helicity_comps)\n    ellipticity = mean(ellip_comps)\n\n    return helicity, ellipticity\nend\n```\n\n\n## References\n\nSearch Coil Magnetometer (SCM) science data\n\n- WB waveforms (scw) [8192 S/s]\n\n- https://themis.igpp.ucla.edu/scm_dataflow.shtml\n\nElectric Field Instruments (EFI) science data\n\n- PB waveforms (efp, vap) [128 S/s; Allocation ~ 1.2h]  \n- WB waveforms (efw, vaw) [8192 S/s; Allocation ~ 43s]\n\n- https://themis.ssl.berkeley.edu/instrument_efi.shtml\n\n",
    "supporting": [
      "ps5_files/figure-typst"
    ],
    "filters": []
  }
}