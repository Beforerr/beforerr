{
  "hash": "cad06ccb24668e325e8988d2a1e55341",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Problem Set 2\nnumber-sections: true\nengine: julia\nfig-format: png\n---\n\n::: {.callout-warning}\nFunctions in this report are experimental, not tested, and may change without notice.\n:::\n\n## Introduction\n\nIn this report, I will demonstrate the application of Julia in space data analysis. Due to its highly flexible type system, **multiple dispatch** feature, and seamless interoperability between Python and C packages, Julia enables the implementation of `SPEDAS` complex functionalities in a concise and generalizable manner, often requiring only a few lines of code.\n\nMore specifically, we utilize\n\n- `DimensionalData` : which provides an abstract array with named dimensions, facilitating more intuitive indexing and generalized manipulation. \n- `Unitful` : which enables seamless unit conversion and supports dimensional analysis\n\nSince Julia features an **abstract type system**, most packages can be used directly and composed seamlessly without unintended side effects. This contrasts with Python, where inheritance and subtyping are commonly used, making it more challenging to share functionality across different classes.\n\n\n\n\n`degap` and `rectify_datetime` are used to clean up the data and rectify the time series (make timestamps uniform).\n\n```julia\nfunction degap(da::DimArray; dim=Ti)\n    dims = otherdims(da, dim)\n    rows = filter(x -> !any(isnan, x), eachslice(da; dims))\n    if !isempty(rows)\n        cat(rows...; dims)\n    else\n        similar(da, (0, size(da, 2)))\n    end\nend\n\nfunction degap(ts::TimeArray)\n    ts[all.(!isnan, eachrow(values(ts)))]\nend\n\nfunction rectify_datetime(da; tol=2, kwargs...)\n    times = dims(da, Ti)\n    t0 = times[1]\n    dtime = Quantity.(times.val .- t0)\n    new_times = TimeseriesTools.rectify(Ti(dtime); tol)[1]\n    set(da, Ti => new_times .+ t0)\nend\n```\n\n`tplot` could be decomposed into multiple steps and lead to better readability and flexibility.\n\n```julia\n\"\"\"\nLay out multiple time series on the same figure across different panels (rows)\n\"\"\"\nfunction tplot(f, tas::AbstractVector; add_legend=true, link_xaxes=true, kwargs...)\n    aps = map(enumerate(tas)) do (i, ta)\n        ap = tplot(f[i, 1], ta; kwargs...)\n        # Hide redundant x labels\n        link_xaxes && i != length(tas) && hidexdecorations!(ap.axis, grid=false)\n        ap\n    end\n    axs = map(ap -> ap.axis, aps)\n    link_xaxes && linkxaxes!(axs...)\n    add_legend && axislegend.(axs)\n    FigureAxes(f, axs)\nend\n\n\"\"\"\nSetup the axis on a position and plot multiple time series on it\n\"\"\"\nfunction tplot(gp::GridPosition, tas::AbstractVector; kwargs...)\n    ax = Axis(gp, ylabel=ylabel(ta))\n    plots = map(tas) do ta\n        tplot!(ax, ta; kwargs...)\n    end\n    ax, plots\nend\n\n\"\"\"\nPlot a multivariate time series on a position in a figure\n\"\"\"\nfunction tplot(gp::GridPosition, ta::AbstractDimArray; labeldim=nothing, kwargs...)\n    args, attributes = _series(ta, kwargs, labeldim)\n    series(gp, args...; attributes...)\nend\n```\n\n::: {.callout-note}\nSome functions in this report have been collected into multiple Julia packages [Speasy.jl](https://github.com/SciQLop/speasy.jl) and [SpaceTools.jl](https://github.com/Beforerr/SpaceTools.jl), please refer to the package for more information.\n:::\n\n## Energy input and energy dissipation\n\n> Compute the total energy input and total energy dissipation in the magnetosphere during a storm, the one which occurred on 17 March, 2015. This was the largest storm of the previous solar cycle. The total energy input rate is: $ε[W]= (4π/μ_0)V B^2 \\sin^4(θ/2) I_0^2$, also widely known as the Akasofu “epsilon” parameter1,2,3,4,5,6, with $θ = acos(B_{z,GSM}/B_{yz,GSM})$, $I_0 =7RE$. Its cumulative integral is: $U_{in}= ∫εdt$ [in PetaJoules]. The magnetospheric energy dissipation rate in the ionosphere and ring current (in J/s or W) is: $W_{md}=[4 10^{13}(∂(-Dst*)/∂t + (-Dst*)/τ_R)+300 AE]$ and its integral is given by: $U_{md}=∫ W_{md} dt$ [in PJ], where: $τ_R=1$ hr is the ring-current decay rate of O+ through charge exchange in the beginning of the storm, and $τ_R=6$ hr late in the storm recovery when H+ is the dominant species, and Dst* is the corrected Dst to account for SW pressure variations6. Compute these quantities by following the crib sheet. Scale factors are included. Translate as needed (in Python) and complete (below lines: “; CONSTRUCT...”) the crib sheet EPSS_Hwk02.1_crib.pro. Produce the plot below. In your answer, explain each panel in the plot.\n\n### Define and load data sets\n\nWe write a simple Julia wrapper around the [Speasy](https://github.com/SciQLop/speasy), a Python package to deal with main Space Physics WebServices using API instead of downloading files. This allows easier integration between Python and Julia.\n\n```julia\nabstract type AbstractDataSet end\n\n@kwdef struct DataSet <: AbstractDataSet\n    name::String\n    parameters::Vector{String}\nend\n\nspeasy() = @pyconst(pyimport(\"speasy\"))\n\nstruct SpeasyVariable\n    py::Py\nend\n\nfunction get_data(args...)\n    res = @pyconst(pyimport(\"speasy\").get_data)(args...)\n    return apply_recursively(res, SpeasyVariable, is_pylist)\nend\n```\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction load_dataset(dataset, args...; name=dataset.name, products=dataset.parameters, provider=\"cda\")\n    map(products) do p\n        replace_fillval_by_nan!(get_data(\"$provider/$name/$p\", args...))\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nload_dataset (generic function with 1 method)\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nOMNI_HRO_PARAMS = [\n    \"Vx\", \"Vy\", \"Vz\", \"flow_speed\",\n    \"BX_GSE\", \"BY_GSM\", \"BZ_GSM\", \"E\",\n    \"AE_INDEX\", \"SYM_H\", \"Pressure\"\n]\n\n\"\"\"\nHigh resolution (1-min), multi-source, near-Earth solar wind magnetic field and plasma data as shifted to Earth's bow shock nose, plus several 1-min geomagnetic activity indices.\n\nReferences:[DOI](https://doi.org/10.48322/45bb-8792)\n\"\"\"\nOMNI_HRO_1MIN = DataSet(\"OMNI_HRO_1MIN\", OMNI_HRO_PARAMS)\n\n\"\"\"\nVersion 2 of OMNI_HRO_1MIN dataset\n\n- [DOI](https://doi.org/10.48322/mj0k-fq60)\n\"\"\"\nOMNI_HRO2_1MIN = DataSet(\"OMNI_HRO2_1MIN\", OMNI_HRO_PARAMS)\n\nOMNI2_H0_MRG1HR = DataSet(\n    \"OMNI2_H0_MRG1HR\",\n    [\"KP1800\", \"DST1800\", \"AE1800\"]\n)\n\ntimespan = [\"2015-03-15\", \"2015-03-22\"] # 7 days\nomni_hro_ds = load_dataset(OMNI_HRO_1MIN, timespan) |> TimeArray\nOMNI2_H0_MRG1HR_ds = load_dataset(OMNI2_H0_MRG1HR, timespan) |> TimeArray\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCan't get OMNI2_H0_MRG1HR/KP1800 without web service, switching to web service\nCan't get OMNI2_H0_MRG1HR/DST1800 without web service, switching to web service\nCan't get OMNI2_H0_MRG1HR/AE1800 without web service, switching to web service\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n168×3 TimeSeries.TimeArray{Float64, 2, Dates.DateTime, Matrix{Float64}} 2015-03-15T00:30:00 to 2015-03-21T23:30:00\n┌─────────────────────┬────────┬─────────┬────────┐\n│                     │ KP1800 │ DST1800 │ AE1800 │\n├─────────────────────┼────────┼─────────┼────────┤\n│ 2015-03-15T00:30:00 │   20.0 │   -11.0 │  159.0 │\n│ 2015-03-15T01:30:00 │   20.0 │   -11.0 │  147.0 │\n│ 2015-03-15T02:30:00 │   20.0 │   -11.0 │  159.0 │\n│ 2015-03-15T03:30:00 │   20.0 │   -12.0 │  170.0 │\n│ 2015-03-15T04:30:00 │   20.0 │   -11.0 │  232.0 │\n│ 2015-03-15T05:30:00 │   20.0 │   -11.0 │  235.0 │\n│ 2015-03-15T06:30:00 │   27.0 │    -9.0 │  317.0 │\n│ 2015-03-15T07:30:00 │   27.0 │    -9.0 │  446.0 │\n│          ⋮          │   ⋮    │    ⋮    │   ⋮    │\n│ 2015-03-21T17:30:00 │   17.0 │   -44.0 │  105.0 │\n│ 2015-03-21T18:30:00 │   17.0 │   -44.0 │   84.0 │\n│ 2015-03-21T19:30:00 │   17.0 │   -44.0 │   72.0 │\n│ 2015-03-21T20:30:00 │   17.0 │   -47.0 │   68.0 │\n│ 2015-03-21T21:30:00 │   13.0 │   -40.0 │   94.0 │\n│ 2015-03-21T22:30:00 │   13.0 │   -43.0 │   55.0 │\n│ 2015-03-21T23:30:00 │   13.0 │   -41.0 │   47.0 │\n└─────────────────────┴────────┴─────────┴────────┘\n                                   153 rows omitted\n```\n:::\n:::\n\n\n\n\n### Akasofu parameter\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction Akasofu_epsilon(B, V)\n    _, By, Bz = B\n    I0 = 7 * Re\n    Bt = norm([By, Bz])\n    θ = acos(Bz / Bt)\n    return (4π / μ0) * V * Bt^2 * sin(θ / 2)^4 * I0^2 |> u\"GW\"\nend\n\nB_ts = omni_hro_ds[:BX_GSE, :BY_GSM, :BZ_GSM] .* u\"nT\"\nV_ts = omni_hro_ds[:flow_speed] .* u\"km/s\"\n\nAkasofu_epsilon_meta = Dict(\n    \"label\" => \"Akasofu Epsilon\"\n)\nAkasofu_epsilon_ts = TimeArray(\n    timestamp(omni_hro_ds),\n    Akasofu_epsilon.(eachrow(values(B_ts)), values(V_ts)),\n    [:ε],\n    Akasofu_epsilon_meta\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10080×1 TimeSeries.TimeArray{Unitful.Quantity{Float64, 𝐋² 𝐌 𝐓⁻³, Unitful.FreeUnits{(GW,), 𝐋² 𝐌 𝐓⁻³, nothing}}, 1, Dates.DateTime, Vector{Unitful.Quantity{Float64, 𝐋² 𝐌 𝐓⁻³, Unitful.FreeUnits{(GW,), 𝐋² 𝐌 𝐓⁻³, nothing}}}} 2015-03-15T00:00:00 to 2015-03-21T23:59:00\n┌─────────────────────┬───────────────┐\n│                     │ ε             │\n├─────────────────────┼───────────────┤\n│ 2015-03-15T00:00:00 │     53.202 GW │\n│ 2015-03-15T00:01:00 │    59.3266 GW │\n│ 2015-03-15T00:02:00 │    62.2223 GW │\n│ 2015-03-15T00:03:00 │    66.7341 GW │\n│ 2015-03-15T00:04:00 │    66.7664 GW │\n│ 2015-03-15T00:05:00 │     64.882 GW │\n│ 2015-03-15T00:06:00 │    67.7737 GW │\n│ 2015-03-15T00:07:00 │    66.3617 GW │\n│          ⋮          │       ⋮       │\n│ 2015-03-21T23:53:00 │        NaN GW │\n│ 2015-03-21T23:54:00 │        NaN GW │\n│ 2015-03-21T23:55:00 │        NaN GW │\n│ 2015-03-21T23:56:00 │ 0.00733769 GW │\n│ 2015-03-21T23:57:00 │  0.0025041 GW │\n│ 2015-03-21T23:58:00 │  0.0070985 GW │\n│ 2015-03-21T23:59:00 │ 0.00196921 GW │\n└─────────────────────┴───────────────┘\n                     10065 rows omitted\n```\n:::\n:::\n\n\n\n### Dst correction\n\nSiscoe etal 1968, JGR found deltaDst = constant*(sqrt(P_after)-sqrt(P_before)) for after/before sudden impulse.\nWe use this here to correct Dst for SW dynamic pressure, relative to prestorm value (Dst=0, Pdyn=2nPa).\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction correct_Dst(dst, P_after, P_before)\n    Siscoe_constant = 13.5u\"nT/sqrt(nPa)\"\n    @. (dst - Siscoe_constant * (sqrt(P_after * u\"nPa\") - sqrt(P_before * u\"nPa\")))\nend\n\nomni_hro_symh = omni_hro_ds[:SYM_H] .* u\"nT\"\nomni_Dst_corrected = correct_Dst(omni_hro_symh, omni_hro_ds[:Pressure], 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10080×1 TimeSeries.TimeArray{Unitful.Quantity{Float64, 𝐌 𝐈⁻¹ 𝐓⁻², Unitful.FreeUnits{(nT,), 𝐌 𝐈⁻¹ 𝐓⁻², nothing}}, 1, Dates.DateTime, Vector{Unitful.Quantity{Float64, 𝐌 𝐈⁻¹ 𝐓⁻², Unitful.FreeUnits{(nT,), 𝐌 𝐈⁻¹ 𝐓⁻², nothing}}}} 2015-03-15T00:00:00 to 2015-03-21T23:59:00\n┌─────────────────────┬────────────────┐\n│                     │ SYM_H_Pressure │\n├─────────────────────┼────────────────┤\n│ 2015-03-15T00:00:00 │    -3.42358 nT │\n│ 2015-03-15T00:01:00 │    -5.36862 nT │\n│ 2015-03-15T00:02:00 │    -3.73869 nT │\n│ 2015-03-15T00:03:00 │     -3.9673 nT │\n│ 2015-03-15T00:04:00 │    -3.53824 nT │\n│ 2015-03-15T00:05:00 │    -3.13192 nT │\n│ 2015-03-15T00:06:00 │    -2.88453 nT │\n│ 2015-03-15T00:07:00 │    -2.84302 nT │\n│          ⋮          │       ⋮        │\n│ 2015-03-21T23:53:00 │         NaN nT │\n│ 2015-03-21T23:54:00 │         NaN nT │\n│ 2015-03-21T23:55:00 │         NaN nT │\n│ 2015-03-21T23:56:00 │    -23.2479 nT │\n│ 2015-03-21T23:57:00 │    -23.2479 nT │\n│ 2015-03-21T23:58:00 │    -22.5591 nT │\n│ 2015-03-21T23:59:00 │    -22.5591 nT │\n└─────────────────────┴────────────────┘\n                      10065 rows omitted\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntplot([omni_hro_symh, omni_Dst_corrected])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-7-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\n### Electric field\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nomni_mVBz = @. -V_ts * B_ts.BZ_GSM |> u\"mV/m\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10080×1 TimeSeries.TimeArray{Unitful.Quantity{Float64, 𝐋 𝐌 𝐈⁻¹ 𝐓⁻³, Unitful.FreeUnits{(m⁻¹, mV), 𝐋 𝐌 𝐈⁻¹ 𝐓⁻³, nothing}}, 1, Dates.DateTime, Vector{Unitful.Quantity{Float64, 𝐋 𝐌 𝐈⁻¹ 𝐓⁻³, Unitful.FreeUnits{(m⁻¹, mV), 𝐋 𝐌 𝐈⁻¹ 𝐓⁻³, nothing}}}} 2015-03-15T00:00:00 to 2015-03-21T23:59:00\n┌─────────────────────┬───────────────────┐\n│                     │ flow_speed_BZ_GSM │\n├─────────────────────┼───────────────────┤\n│ 2015-03-15T00:00:00 │   0.342721 mV m⁻¹ │\n│ 2015-03-15T00:01:00 │    0.65641 mV m⁻¹ │\n│ 2015-03-15T00:02:00 │   0.711816 mV m⁻¹ │\n│ 2015-03-15T00:03:00 │    0.72822 mV m⁻¹ │\n│ 2015-03-15T00:04:00 │    0.74763 mV m⁻¹ │\n│ 2015-03-15T00:05:00 │   0.718425 mV m⁻¹ │\n│ 2015-03-15T00:06:00 │   0.750825 mV m⁻¹ │\n│ 2015-03-15T00:07:00 │     0.7488 mV m⁻¹ │\n│          ⋮          │         ⋮         │\n│ 2015-03-21T23:53:00 │        NaN mV m⁻¹ │\n│ 2015-03-21T23:54:00 │        NaN mV m⁻¹ │\n│ 2015-03-21T23:55:00 │        NaN mV m⁻¹ │\n│ 2015-03-21T23:56:00 │   -6.13815 mV m⁻¹ │\n│ 2015-03-21T23:57:00 │   -6.17108 mV m⁻¹ │\n│ 2015-03-21T23:58:00 │   -6.22842 mV m⁻¹ │\n│ 2015-03-21T23:59:00 │   -6.19553 mV m⁻¹ │\n└─────────────────────┴───────────────────┘\n                         10065 rows omitted\n```\n:::\n:::\n\n\n\n## Cumulative energy input and dissipation\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction integrate(ts)\n    ts = degap(ts)\n    ε = values(ts)\n    times = timestamp(ts)\n    dts = Quantity.(diff(times))\n    ∫ε_dt = cumsum(ε[1:end-1] .* dts) .|> u\"PJ\"\n    Uin_meta = Dict(\n        \"label\" => \"Cumulative energy input\"\n    )\n    TimeArray(times[2:end], ∫ε_dt, [:Uin], Uin_meta)\nend\n\ntau_r(t, t0; τr_i=1u\"hr\", τr_f=6u\"hr\") = τr_i * (t < t0) + τr_f * (t >= t0)\n\nfunction compute_Wmd(dDst_dt, Dst, AE, time, time2transition)\n    # Time-varying tau_r (assume split between initial and late storm)\n    τ_r = tau_r(time, time2transition)\n    factor = u\"erg/s\" / u\"nT\"\n    Wmd_dDstodt = -4e20 * dDst_dt * factor * 1u\"s\"\n    Wmd_dstotau = -4e20 * Dst / τ_r * factor * 1u\"s\"\n    Wmd_AE = 3e15 * AE * factor\n    Wmd_all = Wmd_dDstodt + Wmd_dstotau + Wmd_AE\n    # return (; Wmd_dDstodt, Wmd_dstotau, Wmd_AE, Wmd_all)\n    return Wmd_all\nend\n\nitem(ts) = values(ts)[1]\n\nomni_AE = omni_hro_ds.AE_INDEX .* u\"nT\"\n\nWmd_all_ts = let Dst = omni_Dst_corrected, AE = omni_AE, time2transition = Date(\"2015-03-19\")\n    times = timestamp(Dst)\n    dts = Quantity.(diff(times))\n    dDst_dt = diff(Dst) ./ dts\n    time = times[10]\n    # ([dDst_dt[times], Dst[times], AE[times]])\n    Wmd_all = map(times[2:end]) do time\n        compute_Wmd(item.([dDst_dt[time], Dst[time], AE[time]])..., time, time2transition)\n    end\n    TimeArray(times[2:end], Wmd_all, [:Wmd], Dict(\"label\" => \"Cumulative energy dissipation\"))\nend\n\nUin = integrate(Akasofu_epsilon_ts)\nUout = integrate(Wmd_all_ts)\nrename!(Uout, :Uout)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6338×1 TimeSeries.TimeArray{Unitful.Quantity{Float64, 𝐋² 𝐌 𝐓⁻², Unitful.FreeUnits{(PJ,), 𝐋² 𝐌 𝐓⁻², nothing}}, 1, Dates.DateTime, Vector{Unitful.Quantity{Float64, 𝐋² 𝐌 𝐓⁻², Unitful.FreeUnits{(PJ,), 𝐋² 𝐌 𝐓⁻², nothing}}}} 2015-03-15T00:02:00 to 2015-03-21T23:59:00\n┌─────────────────────┬──────────────┐\n│                     │ Uout         │\n├─────────────────────┼──────────────┤\n│ 2015-03-15T00:02:00 │ 0.0863126 PJ │\n│ 2015-03-15T00:03:00 │  0.028522 PJ │\n│ 2015-03-15T00:04:00 │ 0.0449733 PJ │\n│ 2015-03-15T00:05:00 │ 0.0346158 PJ │\n│ 2015-03-15T00:06:00 │  0.024771 PJ │\n│ 2015-03-15T00:07:00 │ 0.0211541 PJ │\n│ 2015-03-15T00:08:00 │ 0.0256013 PJ │\n│ 2015-03-15T00:09:00 │ 0.0127587 PJ │\n│          ⋮          │      ⋮       │\n│ 2015-03-21T23:48:00 │   267.107 PJ │\n│ 2015-03-21T23:49:00 │    267.11 PJ │\n│ 2015-03-21T23:50:00 │   267.073 PJ │\n│ 2015-03-21T23:51:00 │    267.09 PJ │\n│ 2015-03-21T23:57:00 │   267.109 PJ │\n│ 2015-03-21T23:58:00 │   267.112 PJ │\n│ 2015-03-21T23:59:00 │   267.088 PJ │\n└─────────────────────┴──────────────┘\n                     6323 rows omitted\n```\n:::\n:::\n\n\n\n### Plot\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfig = Figure(; size=(1200, 1200))\ntvars2plot = [\n    [Uin, Uout],\n    Akasofu_epsilon_ts,\n    [omni_hro_symh, OMNI2_H0_MRG1HR_ds.DST1800 .* u\"nT\", omni_Dst_corrected],\n    [omni_AE, OMNI2_H0_MRG1HR_ds.AE1800 .* u\"nT\"],\n    [omni_mVBz, omni_hro_ds.E .* u\"mV/m\"],\n    [omni_hro_ds.Pressure .* u\"nPa\"]\n]\nf, axs = tplot(fig, tvars2plot)\naxs[3].ylabel = \"DST\"\naxs[4].ylabel = \"AE\"\naxs[5].ylabel = \"Electric field\"\naxs[6].ylabel = \"Pressure\"\naxislegend.(axs)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-10-output-1.png){width=1200 height=1200}\n:::\n:::\n\n\n\n## Field line resonances\n\n> Obtain magnetic field data from THEMIS-A for a field line resonances observed on 2008-Sep-05 10 – 20 UT. These have periods of 10-30 mHz and can be seen in Figure 1 of Sarris et al., 2010 [@sarrisTHEMISObservationsSpatial2010]. It would be sufficient to use spin-period (FGS) data. \n\n> i. Show the band-bass filtered data between fmin=1/180s and fmax=1/15s (low-pass using block average function tsmooth2 with window 61 points, subtract it from the original data to get the high-pass, then do tsmooth2 on that with 5 points). Plot the data.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntha_l2_fgm_ds = DataSet(\"THA_L2_FGM\", [\"tha_fgs_gse\"])\ntspan = [\"2008-09-05T10:00:00\", \"2008-09-05T22:00:00\"]\ntha_fgs_gse = load_dataset(tha_l2_fgm_ds, tspan) |> TS\n\ntha_fgs_gse.metadata[\"long_name\"] = \"THA FGS GSE\"\ntha_fgs_gse.metadata[\"units\"] = \"nT\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"nT\"\n```\n:::\n:::\n\n\n\nThe `smooth` (`tsmooth2` in IDL) function is implemented as follows. By using `mapslices`, the function efficiently applies the operation along the desired dimension. This approach is very general and can be used for multiple dimensions.\n\n```julia\nfunction smooth(da::AbstractDimArray, span::Integer; dims=Ti, suffix=\"_smoothed\", kwargs...)\n    new_da = mapslices(da; dims) do slice\n        mean.(RollingWindowArrays.rolling(slice, span; kwargs...))\n    end\n    rebuild(new_da; name=Symbol(da.name, suffix))\nend\n```\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction amap(f, a::AbstractDimArray, b::AbstractDimArray)\n    shared_selectors = DimSelectors(b)\n    data = f(a[shared_selectors], b[shared_selectors])\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\namap (generic function with 1 method)\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nda = tha_fgs_gse\nda_smoothed = smooth(da, 61)\nda_filtered = amap(-, da, da_smoothed)\nda_filtered = rebuild(da_filtered; name=:tha_fgs_gse_filtered)\nda_filtered_smoothed = smooth(da_filtered, 5)\n\nfigure = (; size=(1000, 600))\ntplot([da, da_smoothed, da_filtered_smoothed]; figure)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-13-output-1.png){width=1000 height=600}\n:::\n:::\n\n\n\n### Dynamic power spectrum\n\n> ii. Do a dynamic power spectrum of the unfiltered data.\n\nIn this section, we implement two approaches to represent the time-frequency domain of time series data. The first approach utilizes a window function, while the second employs a wavelet transform. The functions `pspectrum` are dispatched based on the second argument, leveraging Julia's multiple dispatch mechanism.\n\n- Reference: [Matlab](https://www.mathworks.com/help/signal/ref/pspectrum.html), [PySPEDAS : pytplot.tplot_math.dpwrspc](https://github.com/PySPEDAS/PySPEDAS)\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing SignalAnalysis\nusing DimensionalData: Where\n\nfunction pspectrum(x::AbstractDimArray, spec::Spectrogram)\n    fs = SpaceTools.samplingrate(x)\n    y = tfd(x, spec; fs)\n    t0 = dims(x, Ti)[1]\n    times = Ti(y.time .* 1u\"s\" .+ t0)\n    freqs = 𝑓(y.freq * 1u\"Hz\")\n    y_da = DimArray(y.power', (times, freqs))\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npspectrum (generic function with 1 method)\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing ContinuousWavelets\n\n\"\"\"\n    pspectrum(x, wt; kwargs...)\n\nReturns the power spectrum of `x` in the time-frequency domains\n\"\"\"\nfunction pspectrum(x::AbstractDimArray, wt::CWT)\n    fs = SpaceTools.samplingrate(x)\n    res = cwt(x, wt)\n    power = abs.(res) .^ 2\n    n = length(dims(x, Ti))\n    times = dims(x, Ti)\n    freqs = 𝑓(getMeanFreq(computeWavelets(n, wt)[1], fs) * 1u\"Hz\")\n    DimArray(power, (times, freqs))\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nMain.Notebook.pspectrum\n```\n:::\n:::\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nconst DD = DimensionalData\n\n\"\"\"\n    plot_tfr(data; kwargs...)\n\nDisplays time frequency representation using Makie.\n\"\"\"\nfunction plot_tfr(da::DimArray; colorscale=log10, crange=:auto, figure_kwargs...)\n    cmid = median(da)\n    cmax = cmid * 10\n    cmin = cmid / 10\n\n    fig, ax, hm = heatmap(da; colorscale, colorrange=(cmin, cmax))\n    Colorbar(fig[:, end+1], hm)\n\n    # rasterize the heatmap to reduce file size\n    if *(size(da)...) > 32^2\n        hm.rasterize = true\n    end\n\n    fig\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nMain.Notebook.plot_tfr\n```\n:::\n:::\n\n\n\nApplying hamming window and plotting the power spectrum\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nda = TS(tha_fgs_gse[:, 3])\nda = rectify_datetime(da)\n\nspec1 = Spectrogram(nfft=512, noverlap=64, window=hamming)\nres1 = pspectrum(da, spec1)\nplot_tfr(res1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-17-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\nApplying Morlet wavelet and plotting the power spectrum\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nwl2 = wavelet(Morlet(π), β=2)\nres2 = pspectrum(da, wl2)\nplot_tfr(res2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌ Warning: the lowest frequency wavelet has more than 1% its max at zero, so it may not be analytic. Think carefully\n│   lowAprxAnalyt = 0.076815\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/eb0df/src/sanityChecks.jl:7\n┌ Warning: the lowest frequency wavelet has more than 1% its max at zero, so it may not be analytic. Think carefully\n│   lowAprxAnalyt = 0.076815\n└ @ ContinuousWavelets ~/.julia/packages/ContinuousWavelets/eb0df/src/sanityChecks.jl:7\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-18-output-2.png){width=528 height=336}\n:::\n:::\n\n\n\nField line resonances are more visible using window function although with lower resolution. Zoom in on the low frequencies\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nres1_s = res1[𝑓=Where(<=(0.05u\"Hz\"))]\nplot_tfr(res1_s)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-19-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\n### Field aligned coordinate system\n\n> iii. Transform to the field aligned coordinate system, with “Other dimension” being radially inward (minus R). This will give you 3 components: Radially inward, Azimuthal Westward, and Field aligned. Plot and confirm that the compressional component is small.\n\nTo confirm that the compressional component of the magnetic field is small, we need to analyze the fluctuations in the magnetic field and determine whether the component along the background field direction is significantly weaker than the perpendicular components.\n\n`fac_matrix_make` and `rotate` could be easily implemented in few lines. Note that we implement only the `array` version (corresponding to one timestamp), and the `matrix` version could be freely got using Julia `broadcast` operators which also align with dimensions.\n\n```julia\nfunction fac_matrix_make(\n    vec::AbstractVector;\n    xref=[1.0, 0.0, 0.0]\n)\n    z0 = normalize(vec)\n    y0 = normalize(cross(z0, xref))\n    x0 = cross(y0, z0)\n    return vcat(x0', y0', z0')\nend\n\nfunction rotate(da, mat)\n    da = da[DimSelectors(mats)]\n    da_rot = mats .* eachrow(da.data)\n    TS(dims(da, Ti), dims(da, 2), hcat(da_rot...)')\nend\n```\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nda = tha_fgs_gse\n# smooth the data\nmat_da = smooth(da, 601)\n# make the rotation matrix from the smoothed data\nmats = fac_matrix_make.(eachslice(mat_da, dims=Ti))\n# rotate original data\nda_fac = rotate(da, mats)\ntplot([da, da_fac])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-20-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\n### Poloidal vs. toroidal\n\n> iv. Make dynamic power spectra of the radial and azimuthal components. Which of the two components dominates? This determines if the FLR is poloidal or toroidal. (You may use wavelet transform instead of FFT to construct the dynamic power spectrum, if you prefer and can easily do so as in IDL SPEDAS).  Report on your plots with explanations. Show all your code in addition to your plots, with comments included for clarification.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nda_x = da_fac[:, 1]\nda_x = rectify_datetime(da_x)\n\nres_x = pspectrum(da_x, spec1)\nplot_tfr(res_x)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-21-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nda_y = da_fac[:, 2]\nda_y = rectify_datetime(da_y)\n\nres_y = pspectrum(da_y, spec1)\nplot_tfr(res_y)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps2_files/figure-typst/cell-22-output-1.png){width=528 height=336}\n:::\n:::\n\n\n\nWe can see that the power spectrum of the y (azimuthal) component is much higher than the power spectrum of the x (radial) component. This indicates that the FLR is likely to be toroidal.\n\n",
    "supporting": [
      "ps2_files/figure-typst"
    ],
    "filters": []
  }
}