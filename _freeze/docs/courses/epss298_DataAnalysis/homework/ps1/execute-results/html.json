{
  "hash": "00cd4ad7306d7d41df14e0d80c9cb3c1",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Problem Set 1\nnumber-sections: true\nengine: julia\n---\n\n<!-- activate ./docs/courses/epss298_DataAnalysis/-->\n\nThe attached file contains experimental data showing a spectral line observed in a laboratory. Your task is to perform a Bayesian analysis on a grid to adjust the amplitude A of the spectral line and the background flux B. Assume that the spectral line has a Gaussian shape. For physical reasons, the value of A is constrained to be between 0 and 1000 a priori. The value of B is constrained to be between 0 and 3000 a priori. Use a uniform “prior” on A and B on a linear scale.\n\n## Exercise 2\n\n- Test the function provided to you for the physics model of the spectral line. What is the \nvector of return values for A=200, B=1860? Copy the values into your document.\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Distributions\nusing CairoMakie\n\n# Define the model function\nfunction model(A, B, x; xpos=10)\n    d = Normal(xpos, 1.0)\n    return B .+ A .* pdf.(d, x)\nend\n\n# Define the data\ndata = [1837.00283015, 1811.76260793, 1877.0602172, 1923.04345098,\n    1810.09024628, 1898.42037995, 1784.35363285, 1866.72588538,\n    1826.22446702, 1896.58934977, 2043.89952533, 1946.20171261,\n    1842.25394544, 1803.83175398, 1803.74949885, 1844.61491832,\n    1828.0670997, 1816.13580618, 1885.88536203, 1846.00959492]\n\n# Set up the x values\nl = length(data)\nx = 0:(l-1)\n\n# Test the model function with A=200, B=1860\nA = 200\nB = 1860\nmodel_values = model(A, B, x)\nprintln(\"Model values for A=200, B=1860:\")\nprintln(model_values)\n\n# Plot the data and model\nf = Figure()\nax = Axis(f[1, 1], xlabel=\"Pixel\", ylabel=\"Photons Collected\")\nstairs!(ax, x, data, label=\"Data\")\nstairs!(ax, x, model_values, label=\"Model (A=$(A), B=$(B))\")\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel values for A=200, B=1860:\n[1860.0, 1860.0, 1860.000000000001, 1860.000000001827, 1860.0000012151766, 1860.000297343903, 1860.026766045153, 1860.8863696823876, 1870.7981933026376, 1908.3941449038286, 1939.7884560802866, 1908.3941449038286, 1870.7981933026376, 1860.8863696823876, 1860.026766045153, 1860.000297343903, 1860.0000012151766, 1860.000000001827, 1860.000000000001, 1860.0]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps1_files/figure-html/cell-2-output-2.svg){}\n:::\n:::\n\n\n\n- Code a function \"prior\" returning prior pdf p(A,B|I) for a given set of parameters (A, B).  What is the return value for A=200, B=1860? Ideally, write the function in a vectorized form that can return the likelihood values with A and B values given on 2D grids.\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n# Define the prior function\nfunction prior(A, B)\n    if 0 <= A <= 1000 && 0 <= B <= 3000\n        return 1.0 / (1000 * 3000)  # Normalized uniform prior\n    else\n        return 0.0\n    end\nend\n\nprior_value = prior(A, B)\nprintln(\"Prior value for A=200, B=1860: \", prior_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrior value for A=200, B=1860: 3.3333333333333335e-7\n```\n:::\n:::\n\n\n\n- Code a function \"like\" returning the likelihood function p(data|A,B,I) for a given set of parameters. What is the return value for A=200, B=1860? Ideally, write the function in a vectorized form that can return the likelihood values with A and B values given on 2D grids.\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n# Define the likelihood function\nfunction like(A, B, data, x; xpos=10, sigma=30.0)\n    # Calculate the model prediction\n    m = model(A, B, x, xpos=xpos)\n    # Calculate the likelihood assuming Gaussian errors\n    probs = @. pdf(Normal(m, sigma), data)\n    return prod(probs)\nend\n\n# Test the likelihood function with A=200, B=1860\nlikelihood_value = like(A, B, data, x)\nprintln(\"Likelihood value for A=200, B=1860: \", likelihood_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLikelihood value for A=200, B=1860: 1.6409575671741215e-48\n```\n:::\n:::\n\n\n\n- Code a function \"like_times_prior\" returning the products of the values of the likelihood and prior for a given set of parameters. That is the numerator of Bayes' Law. What is the return value for A=200, B=1860?\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n# Define the function for the numerator of Bayes' Law\nfunction like_times_prior(A, B, data, x; xpos=10, sigma=30.0)\n    return like(A, B, data, x, xpos=xpos, sigma=sigma) * prior(A, B)\nend\n\n# Test the function with A=200, B=1860\nposterior_numerator = like_times_prior(A, B, data, x)\nprintln(\"Posterior numerator for A=200, B=1860: \", posterior_numerator)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPosterior numerator for A=200, B=1860: 5.469858557247072e-55\n```\n:::\n:::\n\n\n\n## Exercise 3: \n\na) Add to the code to calculate the joint posterior probability density p(A,B|data,I) of A and B on a 300x300 grid spanning A and B. Note: Use np.meshgrid to generate a 2D grid for the values of A and B.\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n# Create a grid of A and B values\nf = Figure()\nA_values = range(0, 900, length=200) |> collect\nB_values = range(1780, 1940, length=300) |> collect\n\n# Calculate the posterior (unnormalized) for each grid point\nposterior_grid = zeros(length(A_values), length(B_values))\nfor (i, A) in enumerate(A_values)\n    for (j, B) in enumerate(B_values)\n        posterior_grid[i, j] = like_times_prior(A, B, data, x)\n    end\nend\n\nposterior_grid = posterior_grid ./ sum(posterior_grid)\n\n# Find the maximum posterior and its location\nmax_posterior = maximum(posterior_grid)\nmax_idx = argmax(posterior_grid)\nmax_A = A_values[max_idx[1]]\nmax_B = B_values[max_idx[2]]\n\nprintln(\"Maximum posterior value: \", max_posterior)\nprintln(\"Maximum posterior at A = \", max_A, \", B = \", max_B)\n\n# Plot the posterior\nax = Axis(f[1, 1], xlabel=\"Amplitude (A)\", ylabel=\"Background (B)\", title=\"Posterior Probability\")\nhm = heatmap!(ax, A_values, B_values, (posterior_grid))\nColorbar(f[1, 1][1, 2], hm)\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximum posterior value: 0.0009218105353821632\nMaximum posterior at A = 434.1708542713568, B = 1837.7926421404682\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](ps1_files/figure-html/cell-6-output-2.svg){}\n:::\n:::\n\n\n\nb) Make a graph of the posterior distribution in 2D using ax.pcolormesh(). Label the axes. Use a \n300x300 grid over the entire parameter space. Label the axes. Include a color bar with the label. \nc) Draw the same graph as in a) but use a 300x300 grid spanning only the non-zero probability \nregion. Label the axes. Include a color bar with the label. \nd) Show the point of maximum probability with a star symbol (marker=“*”) on the posterior of \n2c). Include a color bar with the label. \ne) Make a new graph identical to the one in Step 1 and show the best fit by superimposing the best \nfit model on the data. Write down the maximum probability values of A and B.\n\n",
    "supporting": [
      "ps1_files"
    ],
    "filters": [],
    "includes": {}
  }
}