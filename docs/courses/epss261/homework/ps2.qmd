---
title: Problem Set 2
number-sections: true
engine: julia
---

## Energy input and energy dissipation

> Compute the total energy input and total energy dissipation in the magnetosphere during a storm, the one which occurred on 17 March, 2015. This was the largest storm of the previous solar cycle. The total energy input rate is: $ε[W]= (4π/μ_0)V B^2 \sin^4(θ/2) I_0^2$, also widely known as the Akasofu “epsilon” parameter1,2,3,4,5,6, with $θ = acos(B_{z,GSM}/B_{yz,GSM})$, $I_0 =7RE$. Its cumulative integral is: $U_{in}= ∫εdt$ [in PetaJoules]. The magnetospheric energy dissipation rate in the ionosphere and ring current (in J/s or W) is: $W_{md}=[4 10^{13}(∂(-Dst*)/∂t + (-Dst*)/τ_R)+300 AE]$ and its integral is given by: $U_{md}=∫ W_{md} dt$ [in PJ], where: $τ_R=1$ hr is the ring-current decay rate of O+ through charge exchange in the beginning of the storm, and $τ_R=6$ hr late in the storm recovery when H+ is the dominant species, and Dst* is the corrected Dst to account for SW pressure variations6. Compute these quantities by following the crib sheet. Scale factors are included. Translate as needed (in Python) and complete (below lines: “; CONSTRUCT...”) the crib sheet EPSS_Hwk02.1_crib.pro. Produce the plot below. In your answer, explain each panel in the plot.

```{julia}
using Speasy
speasy() # need to initialize first because `openssl` used by `speasy` and `Julia` is incompatible

using Unitful
using Unitful: μ0
using UnitfulAstro
using DimensionalData
using TimeSeries
using LinearAlgebra
using SpaceTools
using CairoMakie
const Re = 1UnitfulAstro.Rearth
```

```{julia}
import TimeSeries: TimeArray

function degap(da::DimArray; dim=Ti)
    dims = otherdims(da, dim)
    rows = filter(x -> !any(isnan, x), eachslice(da; dims))
    if !isempty(rows)
        cat(rows...; dims)
    else
        similar(da, (0, size(da, 2)))
    end
end

function degap(ts::TimeArray)
    ts[all.(!isnan, eachrow(values(ts)))]
end
```

### Define and load data sets

```julia
abstract type AbstractDataSet end

@kwdef struct DataSet <: AbstractDataSet
    name::String
    parameters::Vector{String}
end
```

```{julia}
function load_dataset(dataset, args...; name=dataset.name, products=dataset.parameters, provider="cda")
    map(products) do p
        replace_fillval_by_nan!(get_data("$provider/$name/$p", args...))
    end
end
```

```{julia}
OMNI_HRO_PARAMS = [
    "Vx", "Vy", "Vz", "flow_speed",
    "BX_GSE", "BY_GSM", "BZ_GSM", "E",
    "AE_INDEX", "SYM_H", "Pressure"
]

"""
High resolution (1-min), multi-source, near-Earth solar wind magnetic field and plasma data as shifted to Earth's bow shock nose, plus several 1-min geomagnetic activity indices.

# References
- [DOI](https://doi.org/10.48322/45bb-8792)
"""
OMNI_HRO_1MIN = DataSet("OMNI_HRO_1MIN", OMNI_HRO_PARAMS)

"""
Version 2 of OMNI_HRO_1MIN dataset

- [DOI](https://doi.org/10.48322/mj0k-fq60)
"""
OMNI_HRO2_1MIN = DataSet("OMNI_HRO2_1MIN", OMNI_HRO_PARAMS)

OMNI2_H0_MRG1HR = DataSet(
    "OMNI2_H0_MRG1HR",
    ["KP1800", "DST1800", "AE1800"]
)

timespan = ["2015-03-15", "2015-03-22"] # 7 days
omni_hro_ds = load_dataset(OMNI_HRO_1MIN, timespan) |> TimeArray
OMNI2_H0_MRG1HR_ds = load_dataset(OMNI2_H0_MRG1HR, timespan) |> TimeArray
```


### Akasofu parameter

```{julia}
function Akasofu_epsilon(B, V)
    _, By, Bz = B
    I0 = 7 * Re
    Bt = norm([By, Bz])
    θ = acos(Bz / Bt)
    return (4π / μ0) * V * Bt^2 * sin(θ / 2)^4 * I0^2 |> u"GW"
end

B_ts = omni_hro_ds[:BX_GSE, :BY_GSM, :BZ_GSM] .* u"nT"
V_ts = omni_hro_ds[:flow_speed] .* u"km/s"

Akasofu_epsilon_meta = Dict(
    "label" => "Akasofu Epsilon"
)
Akasofu_epsilon_ts = TimeArray(
    timestamp(omni_hro_ds),
    Akasofu_epsilon.(eachrow(values(B_ts)), values(V_ts)),
    [:ε],
    Akasofu_epsilon_meta
)
```

### Dst correction

Siscoe etal 1968, JGR found deltaDst = constant*(sqrt(P_after)-sqrt(P_before)) for after/before sudden impulse.
We use this here to correct Dst for SW dynamic pressure, relative to prestorm value (Dst=0, Pdyn=2nPa).

```{julia}
function correct_Dst(dst, P_after, P_before)
    Siscoe_constant = 13.5u"nT/sqrt(nPa)"
    @. (dst * u"nT" - Siscoe_constant * (sqrt(P_after * u"nPa") - sqrt(P_before * u"nPa")))
end

omni_Dst_corrected = correct_Dst(omni_hro_ds[:SYM_H], omni_hro_ds[:Pressure], 2)
```

### Electric field

```{julia}
omni_mVBz = @. -V_ts * B_ts.BZ_GSM |> u"mV/m"
# OMNI_VxBgse
# omni_mVxBz_gsm
```

## Cumulative energy input and dissipation

```{julia}
function integrate(ts)
    ts = degap(ts)
    ε = values(ts)
    times = timestamp(ts)
    dts = Quantity.(diff(times))
    ∫ε_dt = cumsum(ε[1:end-1] .* dts) .|> u"PJ"
    Uin_meta = Dict(
        "label" => "Cumulative energy input"
    )
    TimeArray(times[2:end], ∫ε_dt, [:Uin], Uin_meta)
end

tau_r(t, t0; τr_i=1u"hr", τr_f=6u"hr") = τr_i * (t < t0) + τr_f * (t >= t0)

function compute_Wmd(dDst_dt, Dst, AE, time, time2transition)
    # Time-varying tau_r (assume split between initial and late storm)
    τ_r = tau_r(time, time2transition)
    factor = u"erg/s" / u"nT"
    Wmd_dDstodt = -4e20 * dDst_dt * factor * 1u"s"
    Wmd_dstotau = -4e20 * Dst / τ_r * factor * 1u"s"
    Wmd_AE = 3e15 * AE * factor
    Wmd_all = Wmd_dDstodt + Wmd_dstotau + Wmd_AE
    # return (; Wmd_dDstodt, Wmd_dstotau, Wmd_AE, Wmd_all)
    return Wmd_all
end

item(ts) = values(ts)[1]

Wmd_all_ts = let Dst = omni_Dst_corrected, AE = omni_hro_ds.AE_INDEX .* u"nT", time2transition = Date("2015-03-19")
    times = timestamp(Dst)
    dts = Quantity.(diff(times))
    dDst_dt = diff(Dst) ./ dts
    time = times[10]
    # ([dDst_dt[times], Dst[times], AE[times]])
    Wmd_all = map(times[2:end]) do time
        compute_Wmd(item.([dDst_dt[time], Dst[time], AE[time]])..., time, time2transition)
    end
    TimeArray(times[2:end], Wmd_all, [:Wmd], Dict("label" => "Cumulative energy dissipation"))
end

Uin = integrate(Akasofu_epsilon_ts)
Uout = integrate(Wmd_all_ts)
```

### Plot

```{julia}
# Plot results
fig = Figure(; size=(1200, 1200))
tvars2plot = [
    [Uin, Uout],
    Akasofu_epsilon_ts,
    [omni_hro_ds.SYM_H, OMNI2_H0_MRG1HR_ds.DST1800, omni_Dst_corrected ./ u"nT"],
    [omni_hro_ds.AE_INDEX, OMNI2_H0_MRG1HR_ds.AE1800],
    [omni_mVBz, omni_hro_ds.E .* u"mV/m"],
    [omni_hro_ds.Pressure]
]
f, axs = tplot!(fig, tvars2plot)
axs[3].ylabel = "DST (nT)"
axs[4].ylabel = "AE (nT)"
axs[5].ylabel = "Electric field (mV/m)"
axs[6].ylabel = "Pressure (nPa)"
axislegend.(axs)
f
```

## Field line resonances

> Obtain magnetic field data from THEMIS-A for a field line resonances observed on 2008-Sep-05 10 – 20 UT. These have periods of 10-30 mHz and can be seen in Figure 1 of Sarris et al., 2010 (Ref. below7). It would be sufficient to use spin-period (FGS) data. 

> i. Show the band-bass filtered data between fmin=1/180s and fmax=1/15s (low-pass using block average function tsmooth2 with window 61 points, subtract it from the original data to get the high-pass, then do tsmooth2 on that with 5 points). Plot the data.

```{julia}
using TimeseriesTools

THA_L2_FGM = DataSet("THA_L2_FGM", ["tha_fgs_gse"])
tspan = ["2008-09-05T10:00:00", "2008-09-05T20:00:00"]

tha_fgs_gse = load_dataset(THA_L2_FGM, tspan) |> TS
```


```{julia}
function amap(f, a::AbstractDimArray, b::AbstractDimArray)
    shared_selectors = DimSelectors(b)
    data = f(a[shared_selectors], b[shared_selectors])
end
```

```{julia}
da = tha_fgs_gse
da_smoothed = smooth(da, 61)
da_filtered = rebuild(amap(-, da, da_smoothed); name=:tha_fgs_gse_filtered)
da_filtered_smoothed = smooth(da_filtered, 5)

tplot([da, da_smoothed, da_filtered_smoothed])
```

### Dynamic power spectrum

> ii. Do a dynamic power spectrum of the unfiltered data.

```{julia}
time = tha_fgs_gse.dims[1].val.data
dtime = Quantity.(time .- time[1])
new_da = TimeseriesTools.rectifytime(
    # TS(dtime, tha_fgs_gse.dims[2], tha_fgs_gse.data)
    TS(dtime, tha_fgs_gse.data[:, 1])
    ; tol=2
)
S = powerspectrum(new_da, 1 / 180)
p = plot(S)
```

### Field aligned coordinate system

> iii. Transform to the field aligned coordinate system, with “Other dimension” being radially inward (minus R). This will give you 3 components: Radially inward, Azimuthal Westward, and Field aligned. Plot and confirm that the compressional component is small.

```julia
function rotate(da, mat)
    da = da[DimSelectors(mats)]
    da_rot = mats .* eachrow(da.data)
    TS(dims(da, Ti), dims(da, 2), hcat(da_rot...)')
end
```

```{julia}
da = tha_fgs_gse
mat_da = smooth(da, 601)
mats = fac_matrix_make.(eachslice(mat_da, dims=Ti))
da_fac = rotate(da, mats)
tplot([da, da_fac])
```

### Poloidal vs. toroidal

> iv. Make dynamic power spectra of the radial and azimuthal components. Which of the two components dominates? This determines if the FLR is poloidal or toroidal. (You may use wavelet transform instead of FFT to construct the dynamic power spectrum, if you prefer and can easily do so as in IDL SPEDAS).  Report on your plots with explanations. Show all your code in addition to your plots, with comments included for clarification.